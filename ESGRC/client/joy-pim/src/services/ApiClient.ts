//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ApiClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authenticate(body: LoginViewModel | undefined , cancelToken?: CancelToken | undefined): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/Account/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    me(  cancelToken?: CancelToken | undefined): Promise<MeModelApiResponse> {
        let url_ = this.baseUrl + "/api/Account/Me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: AxiosResponse): Promise<MeModelApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MeModelApiResponse.fromJS(resultData200);
            return Promise.resolve<MeModelApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MeModelApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateLabel(body: LabelModel | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Admin/AddOrUpdateLabel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateLabel(_response);
        });
    }

    protected processAddOrUpdateLabel(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createServices(body: Service | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Assessment/CreateServices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateServices(_response);
        });
    }

    protected processCreateServices(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createAssessment(body: Assessment | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Assessment/CreateAssessment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAssessment(_response);
        });
    }

    protected processCreateAssessment(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAssessments(  cancelToken?: CancelToken | undefined): Promise<AssessmentDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Assessment/GetAssessments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAssessments(_response);
        });
    }

    protected processGetAssessments(response: AxiosResponse): Promise<AssessmentDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<AssessmentDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getServicesAssessment(  cancelToken?: CancelToken | undefined): Promise<ServiceIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Assessment/GetServicesAssessment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServicesAssessment(_response);
        });
    }

    protected processGetServicesAssessment(response: AxiosResponse): Promise<ServiceIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServiceIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<ServiceIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAssessmentList(  cancelToken?: CancelToken | undefined): Promise<AssessmentIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Assessment/GetAssessmentList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAssessmentList(_response);
        });
    }

    protected processGetAssessmentList(response: AxiosResponse): Promise<AssessmentIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<AssessmentIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentIEnumerableApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addorUpdateAudit(body: Createaudit | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Audit/AddorUpdateAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddorUpdateAudit(_response);
        });
    }

    protected processAddorUpdateAudit(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllAudit(  cancelToken?: CancelToken | undefined): Promise<CreateauditDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Audit/GetAllAudit";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAudit(_response);
        });
    }

    protected processGetAllAudit(response: AxiosResponse): Promise<CreateauditDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateauditDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<CreateauditDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateauditDtoListApiResponse>(null as any);
    }

    /**
     * @param auditId (optional) 
     * @return OK
     */
    getByAuditId(auditId: number | undefined , cancelToken?: CancelToken | undefined): Promise<CreateauditListApiResponse> {
        let url_ = this.baseUrl + "/api/Audit/GetByAuditId?";
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            url_ += "auditId=" + encodeURIComponent("" + auditId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByAuditId(_response);
        });
    }

    protected processGetByAuditId(response: AxiosResponse): Promise<CreateauditListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateauditListApiResponse.fromJS(resultData200);
            return Promise.resolve<CreateauditListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateauditListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdatePeriod(body: Period | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Audit/AddOrUpdatePeriod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdatePeriod(_response);
        });
    }

    protected processAddOrUpdatePeriod(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllPeriod(  cancelToken?: CancelToken | undefined): Promise<PeriodListApiResponse> {
        let url_ = this.baseUrl + "/api/Audit/GetAllPeriod";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPeriod(_response);
        });
    }

    protected processGetAllPeriod(response: AxiosResponse): Promise<PeriodListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PeriodListApiResponse.fromJS(resultData200);
            return Promise.resolve<PeriodListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PeriodListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getPeriodById(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PeriodListApiResponse> {
        let url_ = this.baseUrl + "/api/Audit/GetPeriodById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPeriodById(_response);
        });
    }

    protected processGetPeriodById(response: AxiosResponse): Promise<PeriodListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PeriodListApiResponse.fromJS(resultData200);
            return Promise.resolve<PeriodListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PeriodListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateFiscalYear(body: FiscalYear | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Audit/AddOrUpdateFiscalYear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateFiscalYear(_response);
        });
    }

    protected processAddOrUpdateFiscalYear(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllFiscalYear(  cancelToken?: CancelToken | undefined): Promise<FiscalYearListApiResponse> {
        let url_ = this.baseUrl + "/api/Audit/GetAllFiscalYear";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllFiscalYear(_response);
        });
    }

    protected processGetAllFiscalYear(response: AxiosResponse): Promise<FiscalYearListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FiscalYearListApiResponse.fromJS(resultData200);
            return Promise.resolve<FiscalYearListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FiscalYearListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createCities(body: Cities | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Cities/CreateCities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCities(_response);
        });
    }

    protected processCreateCities(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getCities(  cancelToken?: CancelToken | undefined): Promise<NewCitiesListApiResponse> {
        let url_ = this.baseUrl + "/api/Cities/GetCities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCities(_response);
        });
    }

    protected processGetCities(response: AxiosResponse): Promise<NewCitiesListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewCitiesListApiResponse.fromJS(resultData200);
            return Promise.resolve<NewCitiesListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewCitiesListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getCity(  cancelToken?: CancelToken | undefined): Promise<GeoGraphyIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Cities/GetCity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCity(_response);
        });
    }

    protected processGetCity(response: AxiosResponse): Promise<GeoGraphyIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GeoGraphyIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<GeoGraphyIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GeoGraphyIEnumerableApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    activateCity(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Cities/ActivateCity?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateCity(_response);
        });
    }

    protected processActivateCity(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    activateCityBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Cities/ActivateCityBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateCityBatch(_response);
        });
    }

    protected processActivateCityBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deactivateCity(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Cities/DeactivateCity?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateCity(_response);
        });
    }

    protected processDeactivateCity(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    deactivateCityBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Cities/DeactivateCityBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateCityBatch(_response);
        });
    }

    protected processDeactivateCityBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createCompliance(body: Compliance | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Compliance/CreateCompliance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCompliance(_response);
        });
    }

    protected processCreateCompliance(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllActiveCompliance(  cancelToken?: CancelToken | undefined): Promise<ComplianceIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Compliance/GetAllActiveCompliance";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllActiveCompliance(_response);
        });
    }

    protected processGetAllActiveCompliance(response: AxiosResponse): Promise<ComplianceIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ComplianceIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<ComplianceIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getUserCount(  cancelToken?: CancelToken | undefined): Promise<Int32ApiResponse> {
        let url_ = this.baseUrl + "/api/DashBoard/GetUserCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserCount(_response);
        });
    }

    protected processGetUserCount(response: AxiosResponse): Promise<Int32ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Int32ApiResponse.fromJS(resultData200);
            return Promise.resolve<Int32ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getRecentLoginHistoryCountDateWise(  cancelToken?: CancelToken | undefined): Promise<ReportCountsModelIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/DashBoard/GetRecentLoginHistoryCountDateWise";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRecentLoginHistoryCountDateWise(_response);
        });
    }

    protected processGetRecentLoginHistoryCountDateWise(response: AxiosResponse): Promise<ReportCountsModelIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReportCountsModelIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<ReportCountsModelIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReportCountsModelIEnumerableApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateApiMetadata(body: ApiMetadataDto | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Integration/AddOrUpdateApiMetadata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateApiMetadata(_response);
        });
    }

    protected processAddOrUpdateApiMetadata(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getApiMetadata(  cancelToken?: CancelToken | undefined): Promise<ApiMetadataDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Integration/GetApiMetadata";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApiMetadata(_response);
        });
    }

    protected processGetApiMetadata(response: AxiosResponse): Promise<ApiMetadataDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiMetadataDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiMetadataDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiMetadataDtoListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateApiIntegration(body: ApiIntegration | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Integration/AddOrUpdateApiIntegration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateApiIntegration(_response);
        });
    }

    protected processAddOrUpdateApiIntegration(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getApiIntegration(  cancelToken?: CancelToken | undefined): Promise<ApiIntegrationListApiResponse> {
        let url_ = this.baseUrl + "/api/Integration/GetApiIntegration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApiIntegration(_response);
        });
    }

    protected processGetApiIntegration(response: AxiosResponse): Promise<ApiIntegrationListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiIntegrationListApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiIntegrationListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiIntegrationListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateApiMapping(body: ApiMapping | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Integration/AddOrUpdateApiMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateApiMapping(_response);
        });
    }

    protected processAddOrUpdateApiMapping(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getApiMapping(  cancelToken?: CancelToken | undefined): Promise<ApiMappingListApiResponse> {
        let url_ = this.baseUrl + "/api/Integration/GetApiMapping";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApiMapping(_response);
        });
    }

    protected processGetApiMapping(response: AxiosResponse): Promise<ApiMappingListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiMappingListApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiMappingListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiMappingListApiResponse>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return OK
     */
    getRoles(isActive: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<RoleIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetRoles?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<RoleIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<RoleIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAppConfiguration(  cancelToken?: CancelToken | undefined): Promise<AppConfigurationApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetAppConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAppConfiguration(_response);
        });
    }

    protected processGetAppConfiguration(response: AxiosResponse): Promise<AppConfigurationApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppConfigurationApiResponse.fromJS(resultData200);
            return Promise.resolve<AppConfigurationApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppConfigurationApiResponse>(null as any);
    }

    /**
     * @param languageId (optional) 
     * @return OK
     */
    getLabels(languageId: number | undefined , cancelToken?: CancelToken | undefined): Promise<LabelModelIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetLabels?";
        if (languageId === null)
            throw new Error("The parameter 'languageId' cannot be null.");
        else if (languageId !== undefined)
            url_ += "languageId=" + encodeURIComponent("" + languageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLabels(_response);
        });
    }

    protected processGetLabels(response: AxiosResponse): Promise<LabelModelIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LabelModelIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<LabelModelIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelModelIEnumerableApiResponse>(null as any);
    }

    /**
     * @param languageId (optional) 
     * @return OK
     */
    searchLabels(languageId: number | undefined , cancelToken?: CancelToken | undefined): Promise<LabelModelSearchResultApiResponse> {
        let url_ = this.baseUrl + "/api/Master/SearchLabels?";
        if (languageId === null)
            throw new Error("The parameter 'languageId' cannot be null.");
        else if (languageId !== undefined)
            url_ += "languageId=" + encodeURIComponent("" + languageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchLabels(_response);
        });
    }

    protected processSearchLabels(response: AxiosResponse): Promise<LabelModelSearchResultApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LabelModelSearchResultApiResponse.fromJS(resultData200);
            return Promise.resolve<LabelModelSearchResultApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LabelModelSearchResultApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getLanguages(  cancelToken?: CancelToken | undefined): Promise<LanguageIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLanguages(_response);
        });
    }

    protected processGetLanguages(response: AxiosResponse): Promise<LanguageIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<LanguageIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAppConfig(  cancelToken?: CancelToken | undefined): Promise<AppSettingsIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetAppConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAppConfig(_response);
        });
    }

    protected processGetAppConfig(response: AxiosResponse): Promise<AppSettingsIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppSettingsIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<AppSettingsIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppSettingsIEnumerableApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    activateRole(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Master/ActivateRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateRole(_response);
        });
    }

    protected processActivateRole(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    activateRoleBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Master/ActivateRoleBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateRoleBatch(_response);
        });
    }

    protected processActivateRoleBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deactivateRole(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Master/DeactivateRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateRole(_response);
        });
    }

    protected processDeactivateRole(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    deactivateRoleBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Master/DeactivateRoleBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateRoleBatch(_response);
        });
    }

    protected processDeactivateRoleBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    updateRoles(id: number | undefined, name: string | undefined, description: string | undefined, isActive: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Master/UpdateRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (description === null)
            throw new Error("The parameter 'description' cannot be null.");
        else if (description !== undefined)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRoles(_response);
        });
    }

    protected processUpdateRoles(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param email (optional) 
     * @return OK
     */
    ismail(email: string | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Master/Ismail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsmail(_response);
        });
    }

    protected processIsmail(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param appuserId (optional) 
     * @return OK
     */
    getUserRoles(appuserId: number | undefined , cancelToken?: CancelToken | undefined): Promise<IEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetUserRoles?";
        if (appuserId === null)
            throw new Error("The parameter 'appuserId' cannot be null.");
        else if (appuserId !== undefined)
            url_ += "appuserId=" + encodeURIComponent("" + appuserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserRoles(_response);
        });
    }

    protected processGetUserRoles(response: AxiosResponse): Promise<IEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<IEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IEnumerableApiResponse>(null as any);
    }

    /**
     * @param appuserId (optional) 
     * @param roleId (optional) 
     * @return OK
     */
    deleteRoles(appuserId: number | undefined, roleId: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Master/DeleteRoles?";
        if (appuserId === null)
            throw new Error("The parameter 'appuserId' cannot be null.");
        else if (appuserId !== undefined)
            url_ += "appuserId=" + encodeURIComponent("" + appuserId) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteRoles(_response);
        });
    }

    protected processDeleteRoles(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return OK
     */
    getErrorLogUser(fromDate: string | undefined, toDate: string | undefined , cancelToken?: CancelToken | undefined): Promise<IEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetErrorLogUser?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetErrorLogUser(_response);
        });
    }

    protected processGetErrorLogUser(response: AxiosResponse): Promise<IEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<IEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getRejectReason(  cancelToken?: CancelToken | undefined): Promise<RejectionReasonIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetRejectReason";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRejectReason(_response);
        });
    }

    protected processGetRejectReason(response: AxiosResponse): Promise<RejectionReasonIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RejectionReasonIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<RejectionReasonIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RejectionReasonIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getUploadedFileStatus(  cancelToken?: CancelToken | undefined): Promise<UploadedFileStatusIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetUploadedFileStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUploadedFileStatus(_response);
        });
    }

    protected processGetUploadedFileStatus(response: AxiosResponse): Promise<UploadedFileStatusIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UploadedFileStatusIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<UploadedFileStatusIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadedFileStatusIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTemplateStatus(  cancelToken?: CancelToken | undefined): Promise<TemplateStatusIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetTemplateStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTemplateStatus(_response);
        });
    }

    protected processGetTemplateStatus(response: AxiosResponse): Promise<TemplateStatusIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateStatusIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateStatusIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateStatusIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTables(  cancelToken?: CancelToken | undefined): Promise<TableMetadataIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetTables";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTables(_response);
        });
    }

    protected processGetTables(response: AxiosResponse): Promise<TableMetadataIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TableMetadataIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TableMetadataIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TableMetadataIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTableColumns(  cancelToken?: CancelToken | undefined): Promise<TableMetaDataColumnIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetTableColumns";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTableColumns(_response);
        });
    }

    protected processGetTableColumns(response: AxiosResponse): Promise<TableMetaDataColumnIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TableMetaDataColumnIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TableMetaDataColumnIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TableMetaDataColumnIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getSeasons(  cancelToken?: CancelToken | undefined): Promise<SeasonIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetSeasons";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSeasons(_response);
        });
    }

    protected processGetSeasons(response: AxiosResponse): Promise<SeasonIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SeasonIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<SeasonIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SeasonIEnumerableApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    geoGraphyList(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<GeoGraphyIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GeoGraphyList?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGeoGraphyList(_response);
        });
    }

    protected processGeoGraphyList(response: AxiosResponse): Promise<GeoGraphyIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GeoGraphyIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<GeoGraphyIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GeoGraphyIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getValidationList(  cancelToken?: CancelToken | undefined): Promise<ValidationListIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetValidationList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetValidationList(_response);
        });
    }

    protected processGetValidationList(response: AxiosResponse): Promise<ValidationListIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ValidationListIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<ValidationListIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ValidationListIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getStageActions(  cancelToken?: CancelToken | undefined): Promise<StageActionIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetStageActions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStageActions(_response);
        });
    }

    protected processGetStageActions(response: AxiosResponse): Promise<StageActionIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StageActionIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<StageActionIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StageActionIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getEsgrc(  cancelToken?: CancelToken | undefined): Promise<EsgrcTypeIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetEsgrc";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEsgrc(_response);
        });
    }

    protected processGetEsgrc(response: AxiosResponse): Promise<EsgrcTypeIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EsgrcTypeIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<EsgrcTypeIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EsgrcTypeIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getUom(  cancelToken?: CancelToken | undefined): Promise<UomIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetUom";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUom(_response);
        });
    }

    protected processGetUom(response: AxiosResponse): Promise<UomIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UomIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<UomIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UomIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMonth(  cancelToken?: CancelToken | undefined): Promise<MonthsIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetMonth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMonth(_response);
        });
    }

    protected processGetMonth(response: AxiosResponse): Promise<MonthsIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MonthsIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<MonthsIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MonthsIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getCategory(  cancelToken?: CancelToken | undefined): Promise<CategoryIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: AxiosResponse): Promise<CategoryIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<CategoryIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getStandards(  cancelToken?: CancelToken | undefined): Promise<StandardsIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetStandards";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStandards(_response);
        });
    }

    protected processGetStandards(response: AxiosResponse): Promise<StandardsIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StandardsIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<StandardsIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StandardsIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getIndustry(  cancelToken?: CancelToken | undefined): Promise<IndustryIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetIndustry";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIndustry(_response);
        });
    }

    protected processGetIndustry(response: AxiosResponse): Promise<IndustryIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IndustryIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<IndustryIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IndustryIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getDepartment(  cancelToken?: CancelToken | undefined): Promise<DepartmentIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetDepartment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDepartment(_response);
        });
    }

    protected processGetDepartment(response: AxiosResponse): Promise<DepartmentIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DepartmentIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<DepartmentIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DepartmentIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getQuatter(  cancelToken?: CancelToken | undefined): Promise<QuatterIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetQuatter";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetQuatter(_response);
        });
    }

    protected processGetQuatter(response: AxiosResponse): Promise<QuatterIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuatterIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<QuatterIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuatterIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMonths(  cancelToken?: CancelToken | undefined): Promise<MonthsIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetMonths";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMonths(_response);
        });
    }

    protected processGetMonths(response: AxiosResponse): Promise<MonthsIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MonthsIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<MonthsIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MonthsIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTypes(  cancelToken?: CancelToken | undefined): Promise<TypeIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTypes(_response);
        });
    }

    protected processGetTypes(response: AxiosResponse): Promise<TypeIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TypeIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TypeIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TypeIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getServices(  cancelToken?: CancelToken | undefined): Promise<ServiceIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetServices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServices(_response);
        });
    }

    protected processGetServices(response: AxiosResponse): Promise<ServiceIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServiceIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<ServiceIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTimeDimension(  cancelToken?: CancelToken | undefined): Promise<TimeDimensionIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetTimeDimension";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeDimension(_response);
        });
    }

    protected processGetTimeDimension(response: AxiosResponse): Promise<TimeDimensionIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TimeDimensionIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TimeDimensionIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TimeDimensionIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getFormulaStandards(  cancelToken?: CancelToken | undefined): Promise<FormulaStandardsIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetFormulaStandards";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFormulaStandards(_response);
        });
    }

    protected processGetFormulaStandards(response: AxiosResponse): Promise<FormulaStandardsIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormulaStandardsIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<FormulaStandardsIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormulaStandardsIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getDataviewDimensions(  cancelToken?: CancelToken | undefined): Promise<DataviewDimensionsIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetDataviewDimensions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataviewDimensions(_response);
        });
    }

    protected processGetDataviewDimensions(response: AxiosResponse): Promise<DataviewDimensionsIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataviewDimensionsIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<DataviewDimensionsIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataviewDimensionsIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMetricsPrefix(  cancelToken?: CancelToken | undefined): Promise<MetricsPrefixIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetMetricsPrefix";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricsPrefix(_response);
        });
    }

    protected processGetMetricsPrefix(response: AxiosResponse): Promise<MetricsPrefixIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricsPrefixIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricsPrefixIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricsPrefixIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getCurrency(  cancelToken?: CancelToken | undefined): Promise<CurrencyIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrency(_response);
        });
    }

    protected processGetCurrency(response: AxiosResponse): Promise<CurrencyIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CurrencyIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<CurrencyIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrencyIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getBusinessUnits(  cancelToken?: CancelToken | undefined): Promise<BusinessUnitsIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetBusinessUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBusinessUnits(_response);
        });
    }

    protected processGetBusinessUnits(response: AxiosResponse): Promise<BusinessUnitsIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BusinessUnitsIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<BusinessUnitsIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BusinessUnitsIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getOrganizations(  cancelToken?: CancelToken | undefined): Promise<OrganizationsIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrganizations(_response);
        });
    }

    protected processGetOrganizations(response: AxiosResponse): Promise<OrganizationsIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationsIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<OrganizationsIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationsIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getFacilities(  cancelToken?: CancelToken | undefined): Promise<FacilityIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Master/GetFacilities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFacilities(_response);
        });
    }

    protected processGetFacilities(response: AxiosResponse): Promise<FacilityIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FacilityIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<FacilityIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FacilityIEnumerableApiResponse>(null as any);
    }

    /**
     * @param tableName (optional) 
     * @param body (optional) 
     * @return OK
     */
    addMasterData(tableName: string | undefined, body: any | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/MasterData/AddMasterData?";
        if (tableName === null)
            throw new Error("The parameter 'tableName' cannot be null.");
        else if (tableName !== undefined)
            url_ += "tableName=" + encodeURIComponent("" + tableName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddMasterData(_response);
        });
    }

    protected processAddMasterData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param tableName (optional) 
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateMasterData(tableName: string | undefined, body: any | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/MasterData/AddOrUpdateMasterData?";
        if (tableName === null)
            throw new Error("The parameter 'tableName' cannot be null.");
        else if (tableName !== undefined)
            url_ += "tableName=" + encodeURIComponent("" + tableName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateMasterData(_response);
        });
    }

    protected processAddOrUpdateMasterData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param masterDataID (optional) 
     * @param name (optional) 
     * @return OK
     */
    downloadMasterDataAsExcel(masterDataID: number | undefined, name: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/MasterData/DownloadMasterDataAsExcel?";
        if (masterDataID === null)
            throw new Error("The parameter 'masterDataID' cannot be null.");
        else if (masterDataID !== undefined)
            url_ += "masterDataID=" + encodeURIComponent("" + masterDataID) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadMasterDataAsExcel(_response);
        });
    }

    protected processDownloadMasterDataAsExcel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param masterDataID (optional) 
     * @param name (optional) 
     * @return OK
     */
    downloadMasterDataTemplate(masterDataID: number | undefined, name: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/MasterData/DownloadMasterDataTemplate?";
        if (masterDataID === null)
            throw new Error("The parameter 'masterDataID' cannot be null.");
        else if (masterDataID !== undefined)
            url_ += "masterDataID=" + encodeURIComponent("" + masterDataID) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadMasterDataTemplate(_response);
        });
    }

    protected processDownloadMasterDataTemplate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param masterDataId (optional) 
     * @param file (optional) 
     * @return OK
     */
    uploadMasterDataTemplate(masterDataId: number | undefined, file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MasterData/UploadMasterDataTemplate?";
        if (masterDataId === null)
            throw new Error("The parameter 'masterDataId' cannot be null.");
        else if (masterDataId !== undefined)
            url_ += "masterDataId=" + encodeURIComponent("" + masterDataId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadMasterDataTemplate(_response);
        });
    }

    protected processUploadMasterDataTemplate(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMetric(body: Metric | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/CreateMetric";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMetric(_response);
        });
    }

    protected processCreateMetric(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @param groupId (optional) 
     * @return OK
     */
    updateMetric(ids: number[] | undefined, groupId: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/UpdateMetric?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMetric(_response);
        });
    }

    protected processUpdateMetric(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMetric(  cancelToken?: CancelToken | undefined): Promise<MetricDomainModelListApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetMetric";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetric(_response);
        });
    }

    protected processGetMetric(response: AxiosResponse): Promise<MetricDomainModelListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricDomainModelListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricDomainModelListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricDomainModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getMetricsWithId(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricDomainModelListApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetMetricsWithId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricsWithId(_response);
        });
    }

    protected processGetMetricsWithId(response: AxiosResponse): Promise<MetricDomainModelListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricDomainModelListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricDomainModelListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricDomainModelListApiResponse>(null as any);
    }

    /**
     * @param groupId (optional) 
     * @param regulationtypeid (optional) 
     * @return OK
     */
    getRegulationsWithId(groupId: number | undefined, regulationtypeid: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricDomainModelListApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetRegulationsWithId?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (regulationtypeid === null)
            throw new Error("The parameter 'regulationtypeid' cannot be null.");
        else if (regulationtypeid !== undefined)
            url_ += "regulationtypeid=" + encodeURIComponent("" + regulationtypeid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRegulationsWithId(_response);
        });
    }

    protected processGetRegulationsWithId(response: AxiosResponse): Promise<MetricDomainModelListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricDomainModelListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricDomainModelListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricDomainModelListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMetricList(  cancelToken?: CancelToken | undefined): Promise<MetricListApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetMetricList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricList(_response);
        });
    }

    protected processGetMetricList(response: AxiosResponse): Promise<MetricListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    activateMetric(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/ActivateMetric?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateMetric(_response);
        });
    }

    protected processActivateMetric(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    activateMetricBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/ActivateMetricBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateMetricBatch(_response);
        });
    }

    protected processActivateMetricBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deactivateMetric(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/DeactivateMetric?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateMetric(_response);
        });
    }

    protected processDeactivateMetric(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    deactivateMetricBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/DeactivateMetricBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateMetricBatch(_response);
        });
    }

    protected processDeactivateMetricBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllActiveMetric(  cancelToken?: CancelToken | undefined): Promise<MetricIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetAllActiveMetric";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllActiveMetric(_response);
        });
    }

    protected processGetAllActiveMetric(response: AxiosResponse): Promise<MetricIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getActiveAnswerOptions(  cancelToken?: CancelToken | undefined): Promise<Int64ListApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetActiveAnswerOptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActiveAnswerOptions(_response);
        });
    }

    protected processGetActiveAnswerOptions(response: AxiosResponse): Promise<Int64ListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Int64ListApiResponse.fromJS(resultData200);
            return Promise.resolve<Int64ListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int64ListApiResponse>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return OK
     */
    searchActiveMetrics(isActive: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<MetricIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/SearchActiveMetrics?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchActiveMetrics(_response);
        });
    }

    protected processSearchActiveMetrics(response: AxiosResponse): Promise<MetricIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllMetricType(  cancelToken?: CancelToken | undefined): Promise<MetricTypeIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetAllMetricType";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllMetricType(_response);
        });
    }

    protected processGetAllMetricType(response: AxiosResponse): Promise<MetricTypeIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricTypeIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricTypeIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricTypeIEnumerableApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getAllMetricTypeId(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricTypeIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetAllMetricTypeId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllMetricTypeId(_response);
        });
    }

    protected processGetAllMetricTypeId(response: AxiosResponse): Promise<MetricTypeIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricTypeIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricTypeIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricTypeIEnumerableApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateMetricAnswer(body: MetricAnswerOptionDto | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/AddOrUpdateMetricAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateMetricAnswer(_response);
        });
    }

    protected processAddOrUpdateMetricAnswer(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @param auditId (optional) 
     * @return OK
     */
    getMetricAnswer(templateId: number | undefined, auditId: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricQuestionAnswersDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetMetricAnswer?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            url_ += "auditId=" + encodeURIComponent("" + auditId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricAnswer(_response);
        });
    }

    protected processGetMetricAnswer(response: AxiosResponse): Promise<MetricQuestionAnswersDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricQuestionAnswersDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricQuestionAnswersDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricQuestionAnswersDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validateInput(body: ValidationDomainModel | undefined , cancelToken?: CancelToken | undefined): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/ValidateInput";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidateInput(_response);
        });
    }

    protected processValidateInput(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }

    /**
     * @param assessmentId (optional) 
     * @param processId (optional) 
     * @return OK
     */
    getQuestionAnswerPdf(assessmentId: number | undefined, processId: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Metric/GetQuestionAnswerPdf?";
        if (assessmentId === null)
            throw new Error("The parameter 'assessmentId' cannot be null.");
        else if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "processId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetQuestionAnswerPdf(_response);
        });
    }

    protected processGetQuestionAnswerPdf(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createTaskAction(body: TaskAction | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/CreateTaskAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTaskAction(_response);
        });
    }

    protected processCreateTaskAction(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTaskActions(  cancelToken?: CancelToken | undefined): Promise<TaskActionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetTaskActions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTaskActions(_response);
        });
    }

    protected processGetTaskActions(response: AxiosResponse): Promise<TaskActionDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TaskActionDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TaskActionDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TaskActionDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    deleteMetric(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/DeleteMetric?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMetric(_response);
        });
    }

    protected processDeleteMetric(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    downloadMetricTemplate(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Metric/DownloadMetricTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadMetricTemplate(_response);
        });
    }

    protected processDownloadMetricTemplate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    uploadMetricTemplate(file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/UploadMetricTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadMetricTemplate(_response);
        });
    }

    protected processUploadMetricTemplate(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getPrefixMetrics(  cancelToken?: CancelToken | undefined): Promise<MetricListApiResponse> {
        let url_ = this.baseUrl + "/api/Metric/GetPrefixMetrics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPrefixMetrics(_response);
        });
    }

    protected processGetPrefixMetrics(response: AxiosResponse): Promise<MetricListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMetricGroup(body: MetricGroup | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/CreateMetricGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMetricGroup(_response);
        });
    }

    protected processCreateMetricGroup(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param parentid (optional) 
     * @return OK
     */
    listMetricGroupWithParent(parentid: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricGroupListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/ListMetricGroupWithParent?";
        if (parentid === null)
            throw new Error("The parameter 'parentid' cannot be null.");
        else if (parentid !== undefined)
            url_ += "parentid=" + encodeURIComponent("" + parentid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListMetricGroupWithParent(_response);
        });
    }

    protected processListMetricGroupWithParent(response: AxiosResponse): Promise<MetricGroupListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricGroupListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricGroupListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricGroupListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    activateMetricGroup(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/ActivateMetricGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateMetricGroup(_response);
        });
    }

    protected processActivateMetricGroup(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    activateMetricGroupBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/ActivateMetricGroupBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateMetricGroupBatch(_response);
        });
    }

    protected processActivateMetricGroupBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deactivateMetricGroup(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/DeactivateMetricGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateMetricGroup(_response);
        });
    }

    protected processDeactivateMetricGroup(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteMetricGroup(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/DeleteMetricGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMetricGroup(_response);
        });
    }

    protected processDeleteMetricGroup(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    deactivateMetricGroupBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/DeactivateMetricGroupBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateMetricGroupBatch(_response);
        });
    }

    protected processDeactivateMetricGroupBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getActiveMetricGroupsWithCount(  cancelToken?: CancelToken | undefined): Promise<GetMetricGroupListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetActiveMetricGroupsWithCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActiveMetricGroupsWithCount(_response);
        });
    }

    protected processGetActiveMetricGroupsWithCount(response: AxiosResponse): Promise<GetMetricGroupListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetMetricGroupListApiResponse.fromJS(resultData200);
            return Promise.resolve<GetMetricGroupListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetMetricGroupListApiResponse>(null as any);
    }

    /**
     * @param regulationtypeid (optional) 
     * @return OK
     */
    getActiveRegulationWithCount(regulationtypeid: number | undefined , cancelToken?: CancelToken | undefined): Promise<GetMetricGroupListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetActiveRegulationWithCount?";
        if (regulationtypeid === null)
            throw new Error("The parameter 'regulationtypeid' cannot be null.");
        else if (regulationtypeid !== undefined)
            url_ += "regulationtypeid=" + encodeURIComponent("" + regulationtypeid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActiveRegulationWithCount(_response);
        });
    }

    protected processGetActiveRegulationWithCount(response: AxiosResponse): Promise<GetMetricGroupListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetMetricGroupListApiResponse.fromJS(resultData200);
            return Promise.resolve<GetMetricGroupListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetMetricGroupListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMetricDetails(  cancelToken?: CancelToken | undefined): Promise<GetMetricDetailsModelListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetMetricDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricDetails(_response);
        });
    }

    protected processGetMetricDetails(response: AxiosResponse): Promise<GetMetricDetailsModelListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetMetricDetailsModelListApiResponse.fromJS(resultData200);
            return Promise.resolve<GetMetricDetailsModelListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetMetricDetailsModelListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @param groupId (optional) 
     * @return OK
     */
    deleteMetricGroupId(id: number | undefined, groupId: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/DeleteMetricGroupId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMetricGroupId(_response);
        });
    }

    protected processDeleteMetricGroupId(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deleteParentMetricGroup(id: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/DeleteParentMetricGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteParentMetricGroup(_response);
        });
    }

    protected processDeleteParentMetricGroup(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param groupId (optional) 
     * @return OK
     */
    getMetricsByGroupId(groupId: string | undefined , cancelToken?: CancelToken | undefined): Promise<MetricDomainModelListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetMetricsByGroupId?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricsByGroupId(_response);
        });
    }

    protected processGetMetricsByGroupId(response: AxiosResponse): Promise<MetricDomainModelListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricDomainModelListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricDomainModelListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricDomainModelListApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @return OK
     */
    getPrefixMetricsById(templateId: number | undefined , cancelToken?: CancelToken | undefined): Promise<PrefixMetricsModelListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetPrefixMetricsById?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPrefixMetricsById(_response);
        });
    }

    protected processGetPrefixMetricsById(response: AxiosResponse): Promise<PrefixMetricsModelListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PrefixMetricsModelListApiResponse.fromJS(resultData200);
            return Promise.resolve<PrefixMetricsModelListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PrefixMetricsModelListApiResponse>(null as any);
    }

    /**
     * @param groupId (optional) 
     * @return OK
     */
    getMetricshow(groupId: string | undefined , cancelToken?: CancelToken | undefined): Promise<MgmultiselectionDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetMetricshow?";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricshow(_response);
        });
    }

    protected processGetMetricshow(response: AxiosResponse): Promise<MgmultiselectionDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MgmultiselectionDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<MgmultiselectionDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MgmultiselectionDtoListApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @return OK
     */
    getMetricsByTemplateId(templateId: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricDomainModelListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetMetricsByTemplateId?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricsByTemplateId(_response);
        });
    }

    protected processGetMetricsByTemplateId(response: AxiosResponse): Promise<MetricDomainModelListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricDomainModelListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricDomainModelListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricDomainModelListApiResponse>(null as any);
    }

    /**
     * @param auditid (optional) 
     * @param templatestageid (optional) 
     * @return OK
     */
    getApproveData(auditid: number | undefined, templatestageid: number | undefined , cancelToken?: CancelToken | undefined): Promise<AuditresponsedataListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetApproveData?";
        if (auditid === null)
            throw new Error("The parameter 'auditid' cannot be null.");
        else if (auditid !== undefined)
            url_ += "auditid=" + encodeURIComponent("" + auditid) + "&";
        if (templatestageid === null)
            throw new Error("The parameter 'templatestageid' cannot be null.");
        else if (templatestageid !== undefined)
            url_ += "templatestageid=" + encodeURIComponent("" + templatestageid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApproveData(_response);
        });
    }

    protected processGetApproveData(response: AxiosResponse): Promise<AuditresponsedataListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuditresponsedataListApiResponse.fromJS(resultData200);
            return Promise.resolve<AuditresponsedataListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuditresponsedataListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getMetricGroupWithId(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricGroupListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetMetricGroupWithId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricGroupWithId(_response);
        });
    }

    protected processGetMetricGroupWithId(response: AxiosResponse): Promise<MetricGroupListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricGroupListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricGroupListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricGroupListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMetricGroupWithRegulationList(  cancelToken?: CancelToken | undefined): Promise<MetricGroupListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetMetricGroupWithRegulationList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricGroupWithRegulationList(_response);
        });
    }

    protected processGetMetricGroupWithRegulationList(response: AxiosResponse): Promise<MetricGroupListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricGroupListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricGroupListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricGroupListApiResponse>(null as any);
    }

    /**
     * @param parentId (optional) 
     * @param metricgroupId (optional) 
     * @return OK
     */
    updateParentId(parentId: number | undefined, metricgroupId: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/UpdateParentId?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (metricgroupId === null)
            throw new Error("The parameter 'metricgroupId' cannot be null.");
        else if (metricgroupId !== undefined)
            metricgroupId && metricgroupId.forEach(item => { url_ += "metricgroupId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateParentId(_response);
        });
    }

    protected processUpdateParentId(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param metricgroupId (optional) 
     * @param file (optional) 
     * @return OK
     */
    uploadPdfFile(metricgroupId: number | undefined, file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<Int64ApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/UploadPdfFile?";
        if (metricgroupId === null)
            throw new Error("The parameter 'metricgroupId' cannot be null.");
        else if (metricgroupId !== undefined)
            url_ += "metricgroupId=" + encodeURIComponent("" + metricgroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadPdfFile(_response);
        });
    }

    protected processUploadPdfFile(response: AxiosResponse): Promise<Int64ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Int64ApiResponse.fromJS(resultData200);
            return Promise.resolve<Int64ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int64ApiResponse>(null as any);
    }

    /**
     * @param metricgroupId (optional) 
     * @return OK
     */
    getUploadedFileLink(metricgroupId: number | undefined , cancelToken?: CancelToken | undefined): Promise<UploadedFileListApiResponse> {
        let url_ = this.baseUrl + "/api/MetricGroup/GetUploadedFileLink?";
        if (metricgroupId === null)
            throw new Error("The parameter 'metricgroupId' cannot be null.");
        else if (metricgroupId !== undefined)
            url_ += "metricgroupId=" + encodeURIComponent("" + metricgroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUploadedFileLink(_response);
        });
    }

    protected processGetUploadedFileLink(response: AxiosResponse): Promise<UploadedFileListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UploadedFileListApiResponse.fromJS(resultData200);
            return Promise.resolve<UploadedFileListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadedFileListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addPdfReport(body: PdfReports | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/PdfMerge/AddPdfReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddPdfReport(_response);
        });
    }

    protected processAddPdfReport(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addAirEmissionPdfReport(body: AirEmissionReport | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/PdfMerge/AddAirEmissionPdfReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddAirEmissionPdfReport(_response);
        });
    }

    protected processAddAirEmissionPdfReport(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllPdfReports(  cancelToken?: CancelToken | undefined): Promise<PdfReportsListApiResponse> {
        let url_ = this.baseUrl + "/api/PdfMerge/GetAllPdfReports";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPdfReports(_response);
        });
    }

    protected processGetAllPdfReports(response: AxiosResponse): Promise<PdfReportsListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PdfReportsListApiResponse.fromJS(resultData200);
            return Promise.resolve<PdfReportsListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PdfReportsListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllAirEmissionPdfReports(  cancelToken?: CancelToken | undefined): Promise<AirEmissionReportListApiResponse> {
        let url_ = this.baseUrl + "/api/PdfMerge/GetAllAirEmissionPdfReports";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAirEmissionPdfReports(_response);
        });
    }

    protected processGetAllAirEmissionPdfReports(response: AxiosResponse): Promise<AirEmissionReportListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AirEmissionReportListApiResponse.fromJS(resultData200);
            return Promise.resolve<AirEmissionReportListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AirEmissionReportListApiResponse>(null as any);
    }

    /**
     * @param year (optional) 
     * @param fiscalyearid (optional) 
     * @param quarterid (optional) 
     * @param reportid (optional) 
     * @return OK
     */
    pdfMergerByBlob(year: number | undefined, fiscalyearid: number | undefined, quarterid: number | undefined, reportid: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PdfMerge/PdfMergerByBlob?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (fiscalyearid === null)
            throw new Error("The parameter 'fiscalyearid' cannot be null.");
        else if (fiscalyearid !== undefined)
            url_ += "fiscalyearid=" + encodeURIComponent("" + fiscalyearid) + "&";
        if (quarterid === null)
            throw new Error("The parameter 'quarterid' cannot be null.");
        else if (quarterid !== undefined)
            url_ += "quarterid=" + encodeURIComponent("" + quarterid) + "&";
        if (reportid === null)
            throw new Error("The parameter 'reportid' cannot be null.");
        else if (reportid !== undefined)
            url_ += "reportid=" + encodeURIComponent("" + reportid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPdfMergerByBlob(_response);
        });
    }

    protected processPdfMergerByBlob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param reportid (optional) 
     * @return OK
     */
    pdfGHIReport(reportid: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PdfMerge/PdfGHIReport?";
        if (reportid === null)
            throw new Error("The parameter 'reportid' cannot be null.");
        else if (reportid !== undefined)
            url_ += "reportid=" + encodeURIComponent("" + reportid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPdfGHIReport(_response);
        });
    }

    protected processPdfGHIReport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param metricgroupId (optional) 
     * @param year (optional) 
     * @param timeDimension (optional) 
     * @param quarterId (optional) 
     * @return OK
     */
    pdfMergerByAirBlob(metricgroupId: number | undefined, year: number | undefined, timeDimension: number | undefined, quarterId: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/PdfMerge/PdfMergerByAirBlob?";
        if (metricgroupId === null)
            throw new Error("The parameter 'metricgroupId' cannot be null.");
        else if (metricgroupId !== undefined)
            url_ += "metricgroupId=" + encodeURIComponent("" + metricgroupId) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (timeDimension === null)
            throw new Error("The parameter 'timeDimension' cannot be null.");
        else if (timeDimension !== undefined)
            url_ += "timeDimension=" + encodeURIComponent("" + timeDimension) + "&";
        if (quarterId === null)
            throw new Error("The parameter 'quarterId' cannot be null.");
        else if (quarterId !== undefined)
            url_ += "quarterId=" + encodeURIComponent("" + quarterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPdfMergerByAirBlob(_response);
        });
    }

    protected processPdfMergerByAirBlob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addPdfReport2(body: MergeReport | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/PdfReport/AddPdfReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddPdfReport2(_response);
        });
    }

    protected processAddPdfReport2(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getPdfMerge(  cancelToken?: CancelToken | undefined): Promise<MergeReportDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/PdfReport/GetPdfMerge";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPdfMerge(_response);
        });
    }

    protected processGetPdfMerge(response: AxiosResponse): Promise<MergeReportDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MergeReportDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<MergeReportDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MergeReportDtoListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addorUpdateProcess(body: Process | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/AddorUpdateProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddorUpdateProcess(_response);
        });
    }

    protected processAddorUpdateProcess(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getProcessList(  cancelToken?: CancelToken | undefined): Promise<ProcessDomainModalListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetProcessList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProcessList(_response);
        });
    }

    protected processGetProcessList(response: AxiosResponse): Promise<ProcessDomainModalListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProcessDomainModalListApiResponse.fromJS(resultData200);
            return Promise.resolve<ProcessDomainModalListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProcessDomainModalListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getProcessById(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ProcessApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetProcessById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProcessById(_response);
        });
    }

    protected processGetProcessById(response: AxiosResponse): Promise<ProcessApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProcessApiResponse.fromJS(resultData200);
            return Promise.resolve<ProcessApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProcessApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addTemplateStages(body: TemplateStages[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/AddTemplateStages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTemplateStages(_response);
        });
    }

    protected processAddTemplateStages(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getRoleIds(  cancelToken?: CancelToken | undefined): Promise<Int64ListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetRoleIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoleIds(_response);
        });
    }

    protected processGetRoleIds(response: AxiosResponse): Promise<Int64ListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Int64ListApiResponse.fromJS(resultData200);
            return Promise.resolve<Int64ListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int64ListApiResponse>(null as any);
    }

    /**
     * @param processId (optional) 
     * @return OK
     */
    getProcessStages(processId: number | undefined , cancelToken?: CancelToken | undefined): Promise<TemplateStagesDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetProcessStages?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "processId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProcessStages(_response);
        });
    }

    protected processGetProcessStages(response: AxiosResponse): Promise<TemplateStagesDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateStagesDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateStagesDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateStagesDtoListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    isApprover(  cancelToken?: CancelToken | undefined): Promise<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Process/IsApprover";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsApprover(_response);
        });
    }

    protected processIsApprover(response: AxiosResponse): Promise<BooleanApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanApiResponse.fromJS(resultData200);
            return Promise.resolve<BooleanApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    listProcess(  cancelToken?: CancelToken | undefined): Promise<TemplateStagesDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/ListProcess";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListProcess(_response);
        });
    }

    protected processListProcess(response: AxiosResponse): Promise<TemplateStagesDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateStagesDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateStagesDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateStagesDtoListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    listresponseJson(  cancelToken?: CancelToken | undefined): Promise<ObjectListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/ListresponseJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListresponseJson(_response);
        });
    }

    protected processListresponseJson(response: AxiosResponse): Promise<ObjectListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectListApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getStageList(  cancelToken?: CancelToken | undefined): Promise<ComplianceStageDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetStageList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStageList(_response);
        });
    }

    protected processGetStageList(response: AxiosResponse): Promise<ComplianceStageDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ComplianceStageDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<ComplianceStageDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ComplianceStageDtoListApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @return OK
     */
    templateMetrics(templateId: number | undefined , cancelToken?: CancelToken | undefined): Promise<TemplateGroupDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/TemplateMetrics?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateMetrics(_response);
        });
    }

    protected processTemplateMetrics(response: AxiosResponse): Promise<TemplateGroupDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateGroupDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateGroupDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateGroupDtoListApiResponse>(null as any);
    }

    /**
     * @param tableName (optional) 
     * @return OK
     */
    addTableMetadata(tableName: string | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/AddTableMetadata?";
        if (tableName === null)
            throw new Error("The parameter 'tableName' cannot be null.");
        else if (tableName !== undefined)
            url_ += "tableName=" + encodeURIComponent("" + tableName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTableMetadata(_response);
        });
    }

    protected processAddTableMetadata(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTableMetaData(  cancelToken?: CancelToken | undefined): Promise<TableMetadataListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetTableMetaData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTableMetaData(_response);
        });
    }

    protected processGetTableMetaData(response: AxiosResponse): Promise<TableMetadataListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TableMetadataListApiResponse.fromJS(resultData200);
            return Promise.resolve<TableMetadataListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TableMetadataListApiResponse>(null as any);
    }

    /**
     * @param tableName (optional) 
     * @return OK
     */
    getTableMetaDataColumn(tableName: string | undefined , cancelToken?: CancelToken | undefined): Promise<StringListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetTableMetaDataColumn?";
        if (tableName === null)
            throw new Error("The parameter 'tableName' cannot be null.");
        else if (tableName !== undefined)
            url_ += "tableName=" + encodeURIComponent("" + tableName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTableMetaDataColumn(_response);
        });
    }

    protected processGetTableMetaDataColumn(response: AxiosResponse): Promise<StringListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringListApiResponse.fromJS(resultData200);
            return Promise.resolve<StringListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllTemplateStages(  cancelToken?: CancelToken | undefined): Promise<TemplateStagesListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetAllTemplateStages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllTemplateStages(_response);
        });
    }

    protected processGetAllTemplateStages(response: AxiosResponse): Promise<TemplateStagesListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateStagesListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateStagesListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateStagesListApiResponse>(null as any);
    }

    /**
     * @param processIds (optional) 
     * @param templateIds (optional) 
     * @return OK
     */
    updateStageStatus(processIds: number[] | undefined, templateIds: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/UpdateStageStatus?";
        if (processIds === null)
            throw new Error("The parameter 'processIds' cannot be null.");
        else if (processIds !== undefined)
            processIds && processIds.forEach(item => { url_ += "processIds=" + encodeURIComponent("" + item) + "&"; });
        if (templateIds === null)
            throw new Error("The parameter 'templateIds' cannot be null.");
        else if (templateIds !== undefined)
            templateIds && templateIds.forEach(item => { url_ += "templateIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStageStatus(_response);
        });
    }

    protected processUpdateStageStatus(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param templateStageId (optional) 
     * @param auditId (optional) 
     * @return OK
     */
    updateTemplateStatus(templateStageId: number[] | undefined, auditId: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/UpdateTemplateStatus?";
        if (templateStageId === null)
            throw new Error("The parameter 'templateStageId' cannot be null.");
        else if (templateStageId !== undefined)
            templateStageId && templateStageId.forEach(item => { url_ += "templateStageId=" + encodeURIComponent("" + item) + "&"; });
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            auditId && auditId.forEach(item => { url_ += "auditId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTemplateStatus(_response);
        });
    }

    protected processUpdateTemplateStatus(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param templateStageId (optional) 
     * @param auditId (optional) 
     * @return OK
     */
    updateXML(templateStageId: number[] | undefined, auditId: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Process/UpdateXML?";
        if (templateStageId === null)
            throw new Error("The parameter 'templateStageId' cannot be null.");
        else if (templateStageId !== undefined)
            templateStageId && templateStageId.forEach(item => { url_ += "templateStageId=" + encodeURIComponent("" + item) + "&"; });
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            auditId && auditId.forEach(item => { url_ += "auditId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateXML(_response);
        });
    }

    protected processUpdateXML(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param processIds (optional) 
     * @param templateIds (optional) 
     * @return OK
     */
    updateApproval(processIds: number[] | undefined, templateIds: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/UpdateApproval?";
        if (processIds === null)
            throw new Error("The parameter 'processIds' cannot be null.");
        else if (processIds !== undefined)
            processIds && processIds.forEach(item => { url_ += "processIds=" + encodeURIComponent("" + item) + "&"; });
        if (templateIds === null)
            throw new Error("The parameter 'templateIds' cannot be null.");
        else if (templateIds !== undefined)
            templateIds && templateIds.forEach(item => { url_ += "templateIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateApproval(_response);
        });
    }

    protected processUpdateApproval(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param templateStageId (optional) 
     * @param auditId (optional) 
     * @return OK
     */
    updateApprovalStatus(templateStageId: number[] | undefined, auditId: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/UpdateApprovalStatus?";
        if (templateStageId === null)
            throw new Error("The parameter 'templateStageId' cannot be null.");
        else if (templateStageId !== undefined)
            templateStageId && templateStageId.forEach(item => { url_ += "templateStageId=" + encodeURIComponent("" + item) + "&"; });
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            auditId && auditId.forEach(item => { url_ += "auditId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateApprovalStatus(_response);
        });
    }

    protected processUpdateApprovalStatus(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    isPublisher(  cancelToken?: CancelToken | undefined): Promise<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/Process/IsPublisher";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsPublisher(_response);
        });
    }

    protected processIsPublisher(response: AxiosResponse): Promise<BooleanApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanApiResponse.fromJS(resultData200);
            return Promise.resolve<BooleanApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanApiResponse>(null as any);
    }

    /**
     * @param auditId (optional) 
     * @return OK
     */
    listPublishresponse(auditId: number | undefined , cancelToken?: CancelToken | undefined): Promise<TemplateStagesDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/ListPublishresponse?";
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            url_ += "auditId=" + encodeURIComponent("" + auditId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListPublishresponse(_response);
        });
    }

    protected processListPublishresponse(response: AxiosResponse): Promise<TemplateStagesDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateStagesDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateStagesDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateStagesDtoListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    listAuditResponse(  cancelToken?: CancelToken | undefined): Promise<TemplateStagesDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/ListAuditResponse";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAuditResponse(_response);
        });
    }

    protected processListAuditResponse(response: AxiosResponse): Promise<TemplateStagesDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateStagesDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateStagesDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateStagesDtoListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    auditApprove(  cancelToken?: CancelToken | undefined): Promise<TemplateStagesDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/AuditApprove";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuditApprove(_response);
        });
    }

    protected processAuditApprove(response: AxiosResponse): Promise<TemplateStagesDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateStagesDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateStagesDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateStagesDtoListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllApprovalListTemplateStages(  cancelToken?: CancelToken | undefined): Promise<TemplateStagesListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetAllApprovalListTemplateStages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllApprovalListTemplateStages(_response);
        });
    }

    protected processGetAllApprovalListTemplateStages(response: AxiosResponse): Promise<TemplateStagesListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateStagesListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateStagesListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateStagesListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    raiseIssue(body: AuditIssue | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/RaiseIssue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRaiseIssue(_response);
        });
    }

    protected processRaiseIssue(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    issueWarning(  cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/IssueWarning";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIssueWarning(_response);
        });
    }

    protected processIssueWarning(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createQueries(body: Queries | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/CreateQueries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateQueries(_response);
        });
    }

    protected processCreateQueries(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @param response (optional) 
     * @param processstageid (optional) 
     * @param auditId (optional) 
     * @return OK
     */
    editQueries(id: number | undefined, response: string | undefined, processstageid: number | undefined, auditId: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/EditQueries?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (response === null)
            throw new Error("The parameter 'response' cannot be null.");
        else if (response !== undefined)
            url_ += "response=" + encodeURIComponent("" + response) + "&";
        if (processstageid === null)
            throw new Error("The parameter 'processstageid' cannot be null.");
        else if (processstageid !== undefined)
            url_ += "processstageid=" + encodeURIComponent("" + processstageid) + "&";
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            url_ += "auditId=" + encodeURIComponent("" + auditId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditQueries(_response);
        });
    }

    protected processEditQueries(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getQueriesstatus(  cancelToken?: CancelToken | undefined): Promise<ObjectListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetQueriesstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetQueriesstatus(_response);
        });
    }

    protected processGetQueriesstatus(response: AxiosResponse): Promise<ObjectListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectListApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectListApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getViewQueries(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ObjectListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetViewQueries?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetViewQueries(_response);
        });
    }

    protected processGetViewQueries(response: AxiosResponse): Promise<ObjectListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectListApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAssessmentStage(  cancelToken?: CancelToken | undefined): Promise<AssessmentStageDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Process/GetAssessmentStage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAssessmentStage(_response);
        });
    }

    protected processGetAssessmentStage(response: AxiosResponse): Promise<AssessmentStageDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AssessmentStageDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<AssessmentStageDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AssessmentStageDtoListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    updateAssesmentGroupStatus(  cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Process/UpdateAssesmentGroupStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAssesmentGroupStatus(_response);
        });
    }

    protected processUpdateAssesmentGroupStatus(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    dataIngestion(  cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/StubApi/DataIngestion";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDataIngestion(_response);
        });
    }

    protected processDataIngestion(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param metricgroupid (optional) 
     * @return OK
     */
    getMetricJsonList(metricgroupid: number | undefined , cancelToken?: CancelToken | undefined): Promise<StringObjectDictionaryListApiResponse> {
        let url_ = this.baseUrl + "/api/StubApi/GetMetricJsonList?";
        if (metricgroupid === null)
            throw new Error("The parameter 'metricgroupid' cannot be null.");
        else if (metricgroupid !== undefined)
            url_ += "metricgroupid=" + encodeURIComponent("" + metricgroupid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricJsonList(_response);
        });
    }

    protected processGetMetricJsonList(response: AxiosResponse): Promise<StringObjectDictionaryListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringObjectDictionaryListApiResponse.fromJS(resultData200);
            return Promise.resolve<StringObjectDictionaryListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringObjectDictionaryListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    conversionFormula(  cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/StubApi/ConversionFormula";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConversionFormula(_response);
        });
    }

    protected processConversionFormula(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    timeDimensionCalculation(  cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/StubApi/TimeDimensionCalculation";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTimeDimensionCalculation(_response);
        });
    }

    protected processTimeDimensionCalculation(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param metricGroupId (optional) 
     * @return OK
     */
    getTimeDimensionCalculationList(metricGroupId: number | undefined , cancelToken?: CancelToken | undefined): Promise<StringObjectDictionaryListApiResponse> {
        let url_ = this.baseUrl + "/api/StubApi/GetTimeDimensionCalculationList?";
        if (metricGroupId === null)
            throw new Error("The parameter 'metricGroupId' cannot be null.");
        else if (metricGroupId !== undefined)
            url_ += "metricGroupId=" + encodeURIComponent("" + metricGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeDimensionCalculationList(_response);
        });
    }

    protected processGetTimeDimensionCalculationList(response: AxiosResponse): Promise<StringObjectDictionaryListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringObjectDictionaryListApiResponse.fromJS(resultData200);
            return Promise.resolve<StringObjectDictionaryListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringObjectDictionaryListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createTemplates(body: Template | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/CreateTemplates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTemplates(_response);
        });
    }

    protected processCreateTemplates(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllActiveTemplate(  cancelToken?: CancelToken | undefined): Promise<TemplateIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Template/GetAllActiveTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllActiveTemplate(_response);
        });
    }

    protected processGetAllActiveTemplate(response: AxiosResponse): Promise<TemplateIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateIEnumerableApiResponse>(null as any);
    }

    /**
     * @param templateid (optional) 
     * @param metricgroupid (optional) 
     * @return OK
     */
    deleteTemplategroup(templateid: number | undefined, metricgroupid: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/DeleteTemplategroup?";
        if (templateid === null)
            throw new Error("The parameter 'templateid' cannot be null.");
        else if (templateid !== undefined)
            url_ += "templateid=" + encodeURIComponent("" + templateid) + "&";
        if (metricgroupid === null)
            throw new Error("The parameter 'metricgroupid' cannot be null.");
        else if (metricgroupid !== undefined)
            url_ += "metricgroupid=" + encodeURIComponent("" + metricgroupid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteTemplategroup(_response);
        });
    }

    protected processDeleteTemplategroup(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAllSFTPTemplate(  cancelToken?: CancelToken | undefined): Promise<TemplateIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Template/GetAllSFTPTemplate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSFTPTemplate(_response);
        });
    }

    protected processGetAllSFTPTemplate(response: AxiosResponse): Promise<TemplateIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateIEnumerableApiResponse>(null as any);
    }

    /**
     * @param key (optional) 
     * @param pageNumber (optional) 
     * @param pageCount (optional) 
     * @param isActive (optional) 
     * @return OK
     */
    searchTemplates(key: string | undefined, pageNumber: number | undefined, pageCount: number | undefined, isActive: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<TemplateSearchResultApiResponse> {
        let url_ = this.baseUrl + "/api/Template/SearchTemplates?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageCount === null)
            throw new Error("The parameter 'pageCount' cannot be null.");
        else if (pageCount !== undefined)
            url_ += "pageCount=" + encodeURIComponent("" + pageCount) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchTemplates(_response);
        });
    }

    protected processSearchTemplates(response: AxiosResponse): Promise<TemplateSearchResultApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateSearchResultApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateSearchResultApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateSearchResultApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    linkMetricsToTemplate(body: TemplateMetrics | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/LinkMetricsToTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLinkMetricsToTemplate(_response);
        });
    }

    protected processLinkMetricsToTemplate(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTemplates(  cancelToken?: CancelToken | undefined): Promise<TemplateIAsyncEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/Template/GetTemplates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTemplates(_response);
        });
    }

    protected processGetTemplates(response: AxiosResponse): Promise<TemplateIAsyncEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateIAsyncEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplateIAsyncEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateIAsyncEnumerableApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @return OK
     */
    getTemplateGroup(templateId: number | undefined , cancelToken?: CancelToken | undefined): Promise<TemplayteMetricGroupDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Template/GetTemplateGroup?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTemplateGroup(_response);
        });
    }

    protected processGetTemplateGroup(response: AxiosResponse): Promise<TemplayteMetricGroupDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplayteMetricGroupDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<TemplayteMetricGroupDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplayteMetricGroupDtoListApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @param metricGroupIds (optional) 
     * @param metricIds (optional) 
     * @param isBRSR (optional) 
     * @return OK
     */
    addTemplateGroup(templateId: number | undefined, metricGroupIds: number[] | undefined, metricIds: number[] | undefined, isBRSR: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/AddTemplateGroup?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        if (metricGroupIds === null)
            throw new Error("The parameter 'metricGroupIds' cannot be null.");
        else if (metricGroupIds !== undefined)
            metricGroupIds && metricGroupIds.forEach(item => { url_ += "metricGroupIds=" + encodeURIComponent("" + item) + "&"; });
        if (metricIds === null)
            throw new Error("The parameter 'metricIds' cannot be null.");
        else if (metricIds !== undefined)
            metricIds && metricIds.forEach(item => { url_ += "metricIds=" + encodeURIComponent("" + item) + "&"; });
        if (isBRSR === null)
            throw new Error("The parameter 'isBRSR' cannot be null.");
        else if (isBRSR !== undefined)
            url_ += "isBRSR=" + encodeURIComponent("" + isBRSR) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddTemplateGroup(_response);
        });
    }

    protected processAddTemplateGroup(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @param format (optional) 
     * @return OK
     */
    downloadTemplate(templateId: number | undefined, format: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Template/DownloadTemplate?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadTemplate(_response);
        });
    }

    protected processDownloadTemplate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param assessmentId (optional) 
     * @param auditId (optional) 
     * @return OK
     */
    getFromUploadeddata(assessmentId: number | undefined, auditId: number | undefined , cancelToken?: CancelToken | undefined): Promise<UploadedFileDataDtoApiResponse> {
        let url_ = this.baseUrl + "/api/Template/GetFromUploadeddata?";
        if (assessmentId === null)
            throw new Error("The parameter 'assessmentId' cannot be null.");
        else if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&";
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            url_ += "auditId=" + encodeURIComponent("" + auditId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFromUploadeddata(_response);
        });
    }

    protected processGetFromUploadeddata(response: AxiosResponse): Promise<UploadedFileDataDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UploadedFileDataDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<UploadedFileDataDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadedFileDataDtoApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @param format (optional) 
     * @return OK
     */
    formTemplate(templateId: number | undefined, format: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Template/FormTemplate?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormTemplate(_response);
        });
    }

    protected processFormTemplate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @param metricGroupId (optional) 
     * @param auditId (optional) 
     * @param file (optional) 
     * @return OK
     */
    uploadFormTemplate(templateId: number | undefined, metricGroupId: number | undefined, auditId: number | undefined, file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/UploadFormTemplate?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        if (metricGroupId === null)
            throw new Error("The parameter 'metricGroupId' cannot be null.");
        else if (metricGroupId !== undefined)
            url_ += "metricGroupId=" + encodeURIComponent("" + metricGroupId) + "&";
        if (auditId === null)
            throw new Error("The parameter 'auditId' cannot be null.");
        else if (auditId !== undefined)
            url_ += "auditId=" + encodeURIComponent("" + auditId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadFormTemplate(_response);
        });
    }

    protected processUploadFormTemplate(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param metricGroupId (optional) 
     * @return OK
     */
    getMetricAnswerOptionsDetails(metricGroupId: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricAnswerOptionsListApiResponse> {
        let url_ = this.baseUrl + "/api/Template/GetMetricAnswerOptionsDetails?";
        if (metricGroupId === null)
            throw new Error("The parameter 'metricGroupId' cannot be null.");
        else if (metricGroupId !== undefined)
            url_ += "metricGroupId=" + encodeURIComponent("" + metricGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricAnswerOptionsDetails(_response);
        });
    }

    protected processGetMetricAnswerOptionsDetails(response: AxiosResponse): Promise<MetricAnswerOptionsListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricAnswerOptionsListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricAnswerOptionsListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricAnswerOptionsListApiResponse>(null as any);
    }

    /**
     * @param templateId (optional) 
     * @param format (optional) 
     * @return OK
     */
    downloadSFTPTemplate(templateId: number | undefined, format: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Template/DownloadSFTPTemplate?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadSFTPTemplate(_response);
        });
    }

    protected processDownloadSFTPTemplate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param metricGroupId (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @param format (optional) 
     * @return OK
     */
    downloadMetricGroupTemplate(metricGroupId: number | undefined, month: string | undefined, year: number | undefined, format: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Template/DownloadMetricGroupTemplate?";
        if (metricGroupId === null)
            throw new Error("The parameter 'metricGroupId' cannot be null.");
        else if (metricGroupId !== undefined)
            url_ += "metricGroupId=" + encodeURIComponent("" + metricGroupId) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadMetricGroupTemplate(_response);
        });
    }

    protected processDownloadMetricGroupTemplate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param metricGroupId (optional) 
     * @param month (optional) 
     * @param year (optional) 
     * @param file (optional) 
     * @return OK
     */
    uploadMetricGroupTemplatefile(metricGroupId: number | undefined, month: string | undefined, year: number | undefined, file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/UploadMetricGroupTemplatefile?";
        if (metricGroupId === null)
            throw new Error("The parameter 'metricGroupId' cannot be null.");
        else if (metricGroupId !== undefined)
            url_ += "metricGroupId=" + encodeURIComponent("" + metricGroupId) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadMetricGroupTemplatefile(_response);
        });
    }

    protected processUploadMetricGroupTemplatefile(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param metricGroupId (optional) 
     * @return OK
     */
    listMetricGroupTemplate(metricGroupId: number | undefined , cancelToken?: CancelToken | undefined): Promise<MetricGroupListApiResponse> {
        let url_ = this.baseUrl + "/api/Template/ListMetricGroupTemplate?";
        if (metricGroupId === null)
            throw new Error("The parameter 'metricGroupId' cannot be null.");
        else if (metricGroupId !== undefined)
            url_ += "metricGroupId=" + encodeURIComponent("" + metricGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListMetricGroupTemplate(_response);
        });
    }

    protected processListMetricGroupTemplate(response: AxiosResponse): Promise<MetricGroupListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricGroupListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricGroupListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricGroupListApiResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    uploadSFTPfile(file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/UploadSFTPfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadSFTPfile(_response);
        });
    }

    protected processUploadSFTPfile(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    uploadPdffile(file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/UploadPdffile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadPdffile(_response);
        });
    }

    protected processUploadPdffile(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateStandard(body: MetricStandard | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/AddOrUpdateStandard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateStandard(_response);
        });
    }

    protected processAddOrUpdateStandard(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMetricStandards(  cancelToken?: CancelToken | undefined): Promise<MetricStandardDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Template/GetMetricStandards";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMetricStandards(_response);
        });
    }

    protected processGetMetricStandards(response: AxiosResponse): Promise<MetricStandardDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricStandardDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricStandardDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricStandardDtoListApiResponse>(null as any);
    }

    /**
     * @param format (optional) 
     * @return OK
     */
    downloadStandardData(format: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Template/DownloadStandardData?";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadStandardData(_response);
        });
    }

    protected processDownloadStandardData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createGoalSettings(body: GoalSetting | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Template/CreateGoalSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateGoalSettings(_response);
        });
    }

    protected processCreateGoalSettings(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getGoalSetting(  cancelToken?: CancelToken | undefined): Promise<GoalSettingDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/Template/GetGoalSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGoalSetting(_response);
        });
    }

    protected processGetGoalSetting(response: AxiosResponse): Promise<GoalSettingDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GoalSettingDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<GoalSettingDtoListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GoalSettingDtoListApiResponse>(null as any);
    }

    /**
     * @param email (optional) 
     * @return OK
     */
    sendEmail(email: string | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/Test/SendEmail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendEmail(_response);
        });
    }

    protected processSendEmail(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createTimeDimension(body: CalculationProcess | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/CreateTimeDimension";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTimeDimension(_response);
        });
    }

    protected processCreateTimeDimension(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateTimeDimension(body: TimeDimension | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/AddOrUpdateTimeDimension";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateTimeDimension(_response);
        });
    }

    protected processAddOrUpdateTimeDimension(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @param timeDimensionId (optional) 
     * @param formula (optional) 
     * @return OK
     */
    updateFormula(id: number | undefined, timeDimensionId: number | undefined, formula: string | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/UpdateFormula?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (timeDimensionId === null)
            throw new Error("The parameter 'timeDimensionId' cannot be null.");
        else if (timeDimensionId !== undefined)
            url_ += "timeDimensionId=" + encodeURIComponent("" + timeDimensionId) + "&";
        if (formula === null)
            throw new Error("The parameter 'formula' cannot be null.");
        else if (formula !== undefined)
            url_ += "formula=" + encodeURIComponent("" + formula) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFormula(_response);
        });
    }

    protected processUpdateFormula(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param timeDimensionId (optional) 
     * @return OK
     */
    calculateNewFormula(timeDimensionId: number | undefined , cancelToken?: CancelToken | undefined): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/CalculateNewFormula?";
        if (timeDimensionId === null)
            throw new Error("The parameter 'timeDimensionId' cannot be null.");
        else if (timeDimensionId !== undefined)
            url_ += "timeDimensionId=" + encodeURIComponent("" + timeDimensionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCalculateNewFormula(_response);
        });
    }

    protected processCalculateNewFormula(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTimeDimentionalformula(  cancelToken?: CancelToken | undefined): Promise<CalculationProcessDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/GetTimeDimentionalformula";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeDimentionalformula(_response);
        });
    }

    protected processGetTimeDimentionalformula(response: AxiosResponse): Promise<CalculationProcessDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CalculationProcessDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<CalculationProcessDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CalculationProcessDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getControlList(  cancelToken?: CancelToken | undefined): Promise<MetricListApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/GetControlList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetControlList(_response);
        });
    }

    protected processGetControlList(response: AxiosResponse): Promise<MetricListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricListApiResponse>(null as any);
    }

    /**
     * @param metricgroupId (optional) 
     * @param year (optional) 
     * @param month (optional) 
     * @return OK
     */
    excelDataView(metricgroupId: number | undefined, year: number | undefined, month: number | undefined , cancelToken?: CancelToken | undefined): Promise<ObjectListApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/ExcelDataView?";
        if (metricgroupId === null)
            throw new Error("The parameter 'metricgroupId' cannot be null.");
        else if (metricgroupId !== undefined)
            url_ += "metricgroupId=" + encodeURIComponent("" + metricgroupId) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExcelDataView(_response);
        });
    }

    protected processExcelDataView(response: AxiosResponse): Promise<ObjectListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectListApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getYear(  cancelToken?: CancelToken | undefined): Promise<DataingestionListApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/GetYear";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetYear(_response);
        });
    }

    protected processGetYear(response: AxiosResponse): Promise<DataingestionListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataingestionListApiResponse.fromJS(resultData200);
            return Promise.resolve<DataingestionListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataingestionListApiResponse>(null as any);
    }

    /**
     * @param metricgroupId (optional) 
     * @param year (optional) 
     * @param timeDimension (optional) 
     * @param quarterId (optional) 
     * @return OK
     */
    getTotalJson(metricgroupId: number | undefined, year: number | undefined, timeDimension: number | undefined, quarterId: number | undefined , cancelToken?: CancelToken | undefined): Promise<StringObjectDictionaryListApiResponse> {
        let url_ = this.baseUrl + "/api/TimeDimension/GetTotalJson?";
        if (metricgroupId === null)
            throw new Error("The parameter 'metricgroupId' cannot be null.");
        else if (metricgroupId !== undefined)
            url_ += "metricgroupId=" + encodeURIComponent("" + metricgroupId) + "&";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (timeDimension === null)
            throw new Error("The parameter 'timeDimension' cannot be null.");
        else if (timeDimension !== undefined)
            url_ += "timeDimension=" + encodeURIComponent("" + timeDimension) + "&";
        if (quarterId === null)
            throw new Error("The parameter 'quarterId' cannot be null.");
        else if (quarterId !== undefined)
            url_ += "quarterId=" + encodeURIComponent("" + quarterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTotalJson(_response);
        });
    }

    protected processGetTotalJson(response: AxiosResponse): Promise<StringObjectDictionaryListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringObjectDictionaryListApiResponse.fromJS(resultData200);
            return Promise.resolve<StringObjectDictionaryListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringObjectDictionaryListApiResponse>(null as any);
    }

    /**
     * @param fileName (optional) 
     * @return OK
     */
    getAuthorizedUrlForWrite(fileName: string | undefined , cancelToken?: CancelToken | undefined): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/UploadFile/GetAuthorizedUrlForWrite?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAuthorizedUrlForWrite(_response);
        });
    }

    protected processGetAuthorizedUrlForWrite(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }

    /**
     * @param url (optional) 
     * @return OK
     */
    getAuthorizedUrlForWriteForUrl(url: string | undefined , cancelToken?: CancelToken | undefined): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/UploadFile/GetAuthorizedUrlForWriteForUrl?";
        if (url === null)
            throw new Error("The parameter 'url' cannot be null.");
        else if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAuthorizedUrlForWriteForUrl(_response);
        });
    }

    protected processGetAuthorizedUrlForWriteForUrl(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uploadAndValidateFile(body: UploadedFile | undefined , cancelToken?: CancelToken | undefined): Promise<UploadedFileDataListApiResponse> {
        let url_ = this.baseUrl + "/api/UploadFile/UploadAndValidateFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadAndValidateFile(_response);
        });
    }

    protected processUploadAndValidateFile(response: AxiosResponse): Promise<UploadedFileDataListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UploadedFileDataListApiResponse.fromJS(resultData200);
            return Promise.resolve<UploadedFileDataListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadedFileDataListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    formUploadAndValidateFile(body: UploadedFile | undefined , cancelToken?: CancelToken | undefined): Promise<MetricAnswerOptionsListApiResponse> {
        let url_ = this.baseUrl + "/api/UploadFile/FormUploadAndValidateFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormUploadAndValidateFile(_response);
        });
    }

    protected processFormUploadAndValidateFile(response: AxiosResponse): Promise<MetricAnswerOptionsListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricAnswerOptionsListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricAnswerOptionsListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricAnswerOptionsListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uploadandValiadMetricstandard(body: UploadedFile | undefined , cancelToken?: CancelToken | undefined): Promise<MetricStandardListApiResponse> {
        let url_ = this.baseUrl + "/api/UploadFile/UploadandValiadMetricstandard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadandValiadMetricstandard(_response);
        });
    }

    protected processUploadandValiadMetricstandard(response: AxiosResponse): Promise<MetricStandardListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MetricStandardListApiResponse.fromJS(resultData200);
            return Promise.resolve<MetricStandardListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MetricStandardListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uploadandValiadGoalSettings(body: UploadedFile | undefined , cancelToken?: CancelToken | undefined): Promise<GoalSettingListApiResponse> {
        let url_ = this.baseUrl + "/api/UploadFile/UploadandValiadGoalSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadandValiadGoalSettings(_response);
        });
    }

    protected processUploadandValiadGoalSettings(response: AxiosResponse): Promise<GoalSettingListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GoalSettingListApiResponse.fromJS(resultData200);
            return Promise.resolve<GoalSettingListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GoalSettingListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addOrUpdateUser(body: HyperlinkEdit | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/AddOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrUpdateUser(_response);
        });
    }

    protected processAddOrUpdateUser(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param messageName (optional) 
     * @return OK
     */
    processDataFromTemplate(messageName: string | undefined , cancelToken?: CancelToken | undefined): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/User/ProcessDataFromTemplate?";
        if (messageName === null)
            throw new Error("The parameter 'messageName' cannot be null.");
        else if (messageName !== undefined)
            url_ += "messageName=" + encodeURIComponent("" + messageName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProcessDataFromTemplate(_response);
        });
    }

    protected processProcessDataFromTemplate(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    activeUsers(  cancelToken?: CancelToken | undefined): Promise<AppUserListApiResponse> {
        let url_ = this.baseUrl + "/api/User/ActiveUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActiveUsers(_response);
        });
    }

    protected processActiveUsers(response: AxiosResponse): Promise<AppUserListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppUserListApiResponse.fromJS(resultData200);
            return Promise.resolve<AppUserListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppUserListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    inactiveUsers(  cancelToken?: CancelToken | undefined): Promise<AppUserListApiResponse> {
        let url_ = this.baseUrl + "/api/User/InactiveUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInactiveUsers(_response);
        });
    }

    protected processInactiveUsers(response: AxiosResponse): Promise<AppUserListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppUserListApiResponse.fromJS(resultData200);
            return Promise.resolve<AppUserListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppUserListApiResponse>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @return OK
     */
    searchUsers(isActive: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<UserListItemModelSearchResultApiResponse> {
        let url_ = this.baseUrl + "/api/User/SearchUsers?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchUsers(_response);
        });
    }

    protected processSearchUsers(response: AxiosResponse): Promise<UserListItemModelSearchResultApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserListItemModelSearchResultApiResponse.fromJS(resultData200);
            return Promise.resolve<UserListItemModelSearchResultApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserListItemModelSearchResultApiResponse>(null as any);
    }

    /**
     * @param isActiveFilter (optional) 
     * @return OK
     */
    searchAllUsers(isActiveFilter: IsActiveFilter | undefined , cancelToken?: CancelToken | undefined): Promise<UserListItemModelSearchResultApiResponse> {
        let url_ = this.baseUrl + "/api/User/SearchAllUsers?";
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "isActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchAllUsers(_response);
        });
    }

    protected processSearchAllUsers(response: AxiosResponse): Promise<UserListItemModelSearchResultApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserListItemModelSearchResultApiResponse.fromJS(resultData200);
            return Promise.resolve<UserListItemModelSearchResultApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserListItemModelSearchResultApiResponse>(null as any);
    }

    /**
     * @param userEmail (optional) 
     * @return OK
     */
    getUserByEmail(userEmail: string | undefined , cancelToken?: CancelToken | undefined): Promise<AppUserApiResponse> {
        let url_ = this.baseUrl + "/api/User/GetUserByEmail?";
        if (userEmail === null)
            throw new Error("The parameter 'userEmail' cannot be null.");
        else if (userEmail !== undefined)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserByEmail(_response);
        });
    }

    protected processGetUserByEmail(response: AxiosResponse): Promise<AppUserApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppUserApiResponse.fromJS(resultData200);
            return Promise.resolve<AppUserApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppUserApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @param name (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param email (optional) 
     * @param mobile (optional) 
     * @param isActive (optional) 
     * @param ismailverified (optional) 
     * @param role (optional) 
     * @param roleId (optional) 
     * @param tenantId (optional) 
     * @param genderId (optional) 
     * @param rolelevel (optional) 
     * @param age (optional) 
     * @return OK
     */
    updateUser(id: number | undefined, name: string | undefined, firstName: string | undefined, lastName: string | undefined, email: string | undefined, mobile: string | undefined, isActive: boolean | undefined, ismailverified: boolean | undefined, role: string | undefined, roleId: number | undefined, tenantId: number | undefined, genderId: number | undefined, rolelevel: string | undefined, age: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/UpdateUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (firstName === null)
            throw new Error("The parameter 'firstName' cannot be null.");
        else if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName === null)
            throw new Error("The parameter 'lastName' cannot be null.");
        else if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (mobile === null)
            throw new Error("The parameter 'mobile' cannot be null.");
        else if (mobile !== undefined)
            url_ += "Mobile=" + encodeURIComponent("" + mobile) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (ismailverified === null)
            throw new Error("The parameter 'ismailverified' cannot be null.");
        else if (ismailverified !== undefined)
            url_ += "Ismailverified=" + encodeURIComponent("" + ismailverified) + "&";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (genderId === null)
            throw new Error("The parameter 'genderId' cannot be null.");
        else if (genderId !== undefined)
            url_ += "GenderId=" + encodeURIComponent("" + genderId) + "&";
        if (rolelevel === null)
            throw new Error("The parameter 'rolelevel' cannot be null.");
        else if (rolelevel !== undefined)
            url_ += "Rolelevel=" + encodeURIComponent("" + rolelevel) + "&";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    activateUser(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/ActivateUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateUser(_response);
        });
    }

    protected processActivateUser(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    activateUserBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/ActivateUserBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateUserBatch(_response);
        });
    }

    protected processActivateUserBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    deactivateUser(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/DeactivateUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateUser(_response);
        });
    }

    protected processDeactivateUser(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return OK
     */
    deactivateUserBatch(ids: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/DeactivateUserBatch?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeactivateUserBatch(_response);
        });
    }

    protected processDeactivateUserBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getUserCount2(  cancelToken?: CancelToken | undefined): Promise<Int32ApiResponse> {
        let url_ = this.baseUrl + "/api/User/GetUserCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserCount2(_response);
        });
    }

    protected processGetUserCount2(response: AxiosResponse): Promise<Int32ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Int32ApiResponse.fromJS(resultData200);
            return Promise.resolve<Int32ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addRole(body: Role | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/AddRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddRole(_response);
        });
    }

    protected processAddRole(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addUserRole(body: AppUserRoleModel | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/AddUserRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUserRole(_response);
        });
    }

    protected processAddUserRole(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deleteDepartmentToUser(body: AppUserRole | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/User/DeleteDepartmentToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteDepartmentToUser(_response);
        });
    }

    protected processDeleteDepartmentToUser(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    listFilesFromSftp(  cancelToken?: CancelToken | undefined): Promise<StringIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/User/ListFilesFromSftp";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListFilesFromSftp(_response);
        });
    }

    protected processListFilesFromSftp(response: AxiosResponse): Promise<StringIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<StringIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAccessDataByToken(  cancelToken?: CancelToken | undefined): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/User/GetAccessDataByToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccessDataByToken(_response);
        });
    }

    protected processGetAccessDataByToken(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getAccessDetails(  cancelToken?: CancelToken | undefined): Promise<ObjectListApiResponse> {
        let url_ = this.baseUrl + "/api/User/GetAccessDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccessDetails(_response);
        });
    }

    protected processGetAccessDetails(response: AxiosResponse): Promise<ObjectListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectListApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addorUpdateTaskStepInstance(body: TaskStepInstance | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/AddorUpdateTaskStepInstance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddorUpdateTaskStepInstance(_response);
        });
    }

    protected processAddorUpdateTaskStepInstance(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param workFlowRunId (optional) 
     * @return OK
     */
    getUserInfoByWorkFlowRunId(workFlowRunId: number | undefined , cancelToken?: CancelToken | undefined): Promise<AppUserApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/GetUserInfoByWorkFlowRunId?";
        if (workFlowRunId === null)
            throw new Error("The parameter 'workFlowRunId' cannot be null.");
        else if (workFlowRunId !== undefined)
            url_ += "workFlowRunId=" + encodeURIComponent("" + workFlowRunId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserInfoByWorkFlowRunId(_response);
        });
    }

    protected processGetUserInfoByWorkFlowRunId(response: AxiosResponse): Promise<AppUserApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AppUserApiResponse.fromJS(resultData200);
            return Promise.resolve<AppUserApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AppUserApiResponse>(null as any);
    }

    /**
     * @param planogramOrFamilyName (optional) 
     * @return OK
     */
    getIfAlreadyExistorNot(planogramOrFamilyName: string | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/GetIfAlreadyExistorNot?";
        if (planogramOrFamilyName === null)
            throw new Error("The parameter 'planogramOrFamilyName' cannot be null.");
        else if (planogramOrFamilyName !== undefined)
            url_ += "planogramOrFamilyName=" + encodeURIComponent("" + planogramOrFamilyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIfAlreadyExistorNot(_response);
        });
    }

    protected processGetIfAlreadyExistorNot(response: AxiosResponse): Promise<BooleanApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanApiResponse.fromJS(resultData200);
            return Promise.resolve<BooleanApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanApiResponse>(null as any);
    }

    /**
     * @param action (optional) 
     * @param userComments (optional) 
     * @param body (optional) 
     * @return OK
     */
    updateWorkflowstatusBatch(action: string | undefined, userComments: string | undefined, body: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/UpdateWorkflowstatusBatch?";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        if (userComments === null)
            throw new Error("The parameter 'userComments' cannot be null.");
        else if (userComments !== undefined)
            url_ += "userComments=" + encodeURIComponent("" + userComments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateWorkflowstatusBatch(_response);
        });
    }

    protected processUpdateWorkflowstatusBatch(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param action (optional) 
     * @return OK
     */
    getTask(action: string | undefined , cancelToken?: CancelToken | undefined): Promise<TaskStepInstanceListApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/GetTask?";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTask(_response);
        });
    }

    protected processGetTask(response: AxiosResponse): Promise<TaskStepInstanceListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TaskStepInstanceListApiResponse.fromJS(resultData200);
            return Promise.resolve<TaskStepInstanceListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TaskStepInstanceListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getPlanogramRecordList(  cancelToken?: CancelToken | undefined): Promise<PlanagromRecortListListApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/GetPlanogramRecordList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPlanogramRecordList(_response);
        });
    }

    protected processGetPlanogramRecordList(response: AxiosResponse): Promise<PlanagromRecortListListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanagromRecortListListApiResponse.fromJS(resultData200);
            return Promise.resolve<PlanagromRecortListListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanagromRecortListListApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    getApprovedorRejectedList(  cancelToken?: CancelToken | undefined): Promise<PlanagromRecortListListApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/GetApprovedorRejectedList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetApprovedorRejectedList(_response);
        });
    }

    protected processGetApprovedorRejectedList(response: AxiosResponse): Promise<PlanagromRecortListListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanagromRecortListListApiResponse.fromJS(resultData200);
            return Promise.resolve<PlanagromRecortListListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanagromRecortListListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addorUpdateWorkflowRun(body: WorkflowRun | undefined , cancelToken?: CancelToken | undefined): Promise<WorkflowRunApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/AddorUpdateWorkflowRun";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddorUpdateWorkflowRun(_response);
        });
    }

    protected processAddorUpdateWorkflowRun(response: AxiosResponse): Promise<WorkflowRunApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WorkflowRunApiResponse.fromJS(resultData200);
            return Promise.resolve<WorkflowRunApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WorkflowRunApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateUserAction(body: TasklevelSequence[] | undefined , cancelToken?: CancelToken | undefined): Promise<TasklevelSequenceListApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/UpdateUserAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUserAction(_response);
        });
    }

    protected processUpdateUserAction(response: AxiosResponse): Promise<TasklevelSequenceListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TasklevelSequenceListApiResponse.fromJS(resultData200);
            return Promise.resolve<TasklevelSequenceListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TasklevelSequenceListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uidSearchByCriteria(body: UidSearchModel | undefined , cancelToken?: CancelToken | undefined): Promise<PlanagromRecortListListApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/UidSearchByCriteria";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUidSearchByCriteria(_response);
        });
    }

    protected processUidSearchByCriteria(response: AxiosResponse): Promise<PlanagromRecortListListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanagromRecortListListApiResponse.fromJS(resultData200);
            return Promise.resolve<PlanagromRecortListListApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanagromRecortListListApiResponse>(null as any);
    }

    /**
     * @param isGetAll (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param fileName (optional) 
     * @return OK
     */
    exportExcel(isGetAll: boolean | undefined, startDate: string | undefined, endDate: string | undefined, fileName: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkFlow/ExportExcel?";
        if (isGetAll === null)
            throw new Error("The parameter 'isGetAll' cannot be null.");
        else if (isGetAll !== undefined)
            url_ += "isGetAll=" + encodeURIComponent("" + isGetAll) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportExcel(_response);
        });
    }

    protected processExportExcel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uIDExportExcel(body: UidSearchModel | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkFlow/UIDExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUIDExportExcel(_response);
        });
    }

    protected processUIDExportExcel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    emailContent(  cancelToken?: CancelToken | undefined): Promise<EmailContentModelApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/EmailContent";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailContent(_response);
        });
    }

    protected processEmailContent(response: AxiosResponse): Promise<EmailContentModelApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EmailContentModelApiResponse.fromJS(resultData200);
            return Promise.resolve<EmailContentModelApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmailContentModelApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    sentemail(  cancelToken?: CancelToken | undefined): Promise<StringApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/Sentemail";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSentemail(_response);
        });
    }

    protected processSentemail(response: AxiosResponse): Promise<StringApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResponse.fromJS(resultData200);
            return Promise.resolve<StringApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateRejectedName(body: string[] | undefined , cancelToken?: CancelToken | undefined): Promise<ApiResponse> {
        let url_ = this.baseUrl + "/api/WorkFlow/UpdateRejectedName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRejectedName(_response);
        });
    }

    protected processUpdateRejectedName(response: AxiosResponse): Promise<ApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResponse.fromJS(resultData200);
            return Promise.resolve<ApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiResponse>(null as any);
    }

    /**
     * @param assessmentid (optional) 
     * @param auditid (optional) 
     * @return OK
     */
    downloadXmlFile(assessmentid: number | undefined, auditid: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/XmlFileDownlod/DownloadXmlFile?";
        if (assessmentid === null)
            throw new Error("The parameter 'assessmentid' cannot be null.");
        else if (assessmentid !== undefined)
            url_ += "assessmentid=" + encodeURIComponent("" + assessmentid) + "&";
        if (auditid === null)
            throw new Error("The parameter 'auditid' cannot be null.");
        else if (auditid !== undefined)
            url_ += "auditid=" + encodeURIComponent("" + auditid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadXmlFile(_response);
        });
    }

    protected processDownloadXmlFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AirEmissionReport implements IAirEmissionReport {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    guid?: string | undefined;
    reportName?: string | undefined;
    pageNumber?: number | undefined;
    url?: string | undefined;
    type?: string | undefined;

    constructor(data?: IAirEmissionReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.guid = _data["guid"];
            this.reportName = _data["reportName"];
            this.pageNumber = _data["pageNumber"];
            this.url = _data["url"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AirEmissionReport {
        data = typeof data === 'object' ? data : {};
        let result = new AirEmissionReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["guid"] = this.guid;
        data["reportName"] = this.reportName;
        data["pageNumber"] = this.pageNumber;
        data["url"] = this.url;
        data["type"] = this.type;
        return data;
    }
}

export interface IAirEmissionReport {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    guid?: string | undefined;
    reportName?: string | undefined;
    pageNumber?: number | undefined;
    url?: string | undefined;
    type?: string | undefined;
}

export class AirEmissionReportListApiResponse implements IAirEmissionReportListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AirEmissionReport[] | undefined;
    hasError?: boolean;

    constructor(data?: IAirEmissionReportListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AirEmissionReport.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AirEmissionReportListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AirEmissionReportListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAirEmissionReportListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AirEmissionReport[] | undefined;
    hasError?: boolean;
}

export class ApiIntegration implements IApiIntegration {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    apiId?: number;
    path?: string | undefined;
    type?: string | undefined;
    parameter?: string | undefined;

    constructor(data?: IApiIntegration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.apiId = _data["apiId"];
            this.path = _data["path"];
            this.type = _data["type"];
            this.parameter = _data["parameter"];
        }
    }

    static fromJS(data: any): ApiIntegration {
        data = typeof data === 'object' ? data : {};
        let result = new ApiIntegration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["apiId"] = this.apiId;
        data["path"] = this.path;
        data["type"] = this.type;
        data["parameter"] = this.parameter;
        return data;
    }
}

export interface IApiIntegration {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    apiId?: number;
    path?: string | undefined;
    type?: string | undefined;
    parameter?: string | undefined;
}

export class ApiIntegrationListApiResponse implements IApiIntegrationListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ApiIntegration[] | undefined;
    hasError?: boolean;

    constructor(data?: IApiIntegrationListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApiIntegration.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ApiIntegrationListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiIntegrationListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IApiIntegrationListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ApiIntegration[] | undefined;
    hasError?: boolean;
}

export class ApiMapping implements IApiMapping {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    integrationId?: number;
    source?: string | undefined;
    destination?: string | undefined;

    constructor(data?: IApiMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.integrationId = _data["integrationId"];
            this.source = _data["source"];
            this.destination = _data["destination"];
        }
    }

    static fromJS(data: any): ApiMapping {
        data = typeof data === 'object' ? data : {};
        let result = new ApiMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["integrationId"] = this.integrationId;
        data["source"] = this.source;
        data["destination"] = this.destination;
        return data;
    }
}

export interface IApiMapping {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    integrationId?: number;
    source?: string | undefined;
    destination?: string | undefined;
}

export class ApiMappingListApiResponse implements IApiMappingListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ApiMapping[] | undefined;
    hasError?: boolean;

    constructor(data?: IApiMappingListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApiMapping.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ApiMappingListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiMappingListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IApiMappingListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ApiMapping[] | undefined;
    hasError?: boolean;
}

export class ApiMetadataDto implements IApiMetadataDto {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    baseUrl?: string | undefined;
    name?: string | undefined;
    secretKeyName?: string | undefined;
    secretValue?: { [key: string]: string; } | undefined;

    constructor(data?: IApiMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.baseUrl = _data["baseUrl"];
            this.name = _data["name"];
            this.secretKeyName = _data["secretKeyName"];
            if (_data["secretValue"]) {
                this.secretValue = {} as any;
                for (let key in _data["secretValue"]) {
                    if (_data["secretValue"].hasOwnProperty(key))
                        (<any>this.secretValue)![key] = _data["secretValue"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApiMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["baseUrl"] = this.baseUrl;
        data["name"] = this.name;
        data["secretKeyName"] = this.secretKeyName;
        if (this.secretValue) {
            data["secretValue"] = {};
            for (let key in this.secretValue) {
                if (this.secretValue.hasOwnProperty(key))
                    (<any>data["secretValue"])[key] = (<any>this.secretValue)[key];
            }
        }
        return data;
    }
}

export interface IApiMetadataDto {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    baseUrl?: string | undefined;
    name?: string | undefined;
    secretKeyName?: string | undefined;
    secretValue?: { [key: string]: string; } | undefined;
}

export class ApiMetadataDtoListApiResponse implements IApiMetadataDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ApiMetadataDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IApiMetadataDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ApiMetadataDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ApiMetadataDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiMetadataDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IApiMetadataDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ApiMetadataDto[] | undefined;
    hasError?: boolean;
}

export class ApiResponse implements IApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: any | undefined;
    hasError?: boolean;

    constructor(data?: IApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"];
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: any | undefined;
    hasError?: boolean;
}

export class AppConfiguration implements IAppConfiguration {
    apiUrl?: string | undefined;
    appUrl?: string | undefined;
    b2C?: B2CConfiguration;

    constructor(data?: IAppConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiUrl = _data["apiUrl"];
            this.appUrl = _data["appUrl"];
            this.b2C = _data["b2C"] ? B2CConfiguration.fromJS(_data["b2C"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AppConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new AppConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiUrl"] = this.apiUrl;
        data["appUrl"] = this.appUrl;
        data["b2C"] = this.b2C ? this.b2C.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAppConfiguration {
    apiUrl?: string | undefined;
    appUrl?: string | undefined;
    b2C?: B2CConfiguration;
}

export class AppConfigurationApiResponse implements IAppConfigurationApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AppConfiguration;
    hasError?: boolean;

    constructor(data?: IAppConfigurationApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? AppConfiguration.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AppConfigurationApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppConfigurationApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAppConfigurationApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AppConfiguration;
    hasError?: boolean;
}

export class AppSettings implements IAppSettings {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
    value?: string | undefined;
    jsonValue?: string | undefined;

    constructor(data?: IAppSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.value = _data["value"];
            this.jsonValue = _data["jsonValue"];
        }
    }

    static fromJS(data: any): AppSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        data["value"] = this.value;
        data["jsonValue"] = this.jsonValue;
        return data;
    }
}

export interface IAppSettings {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
    value?: string | undefined;
    jsonValue?: string | undefined;
}

export class AppSettingsIEnumerableApiResponse implements IAppSettingsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AppSettings[] | undefined;
    hasError?: boolean;

    constructor(data?: IAppSettingsIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AppSettings.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AppSettingsIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAppSettingsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AppSettings[] | undefined;
    hasError?: boolean;
}

export class AppUser implements IAppUser {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    address?: string | undefined;
    email!: string;
    encryptionKey?: string | undefined;
    firstName?: string | undefined;
    hasAcceptedPrivacyPolicy?: boolean;
    hasAcceptedTerms?: boolean;
    isDeleted?: boolean;
    isemailverified?: boolean;
    lastName?: string | undefined;
    mobile!: string;
    name!: string;
    password?: string | undefined;
    verificationKey?: string | undefined;
    verificationKeyExpiryTime?: string;

    constructor(data?: IAppUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.address = _data["address"];
            this.email = _data["email"];
            this.encryptionKey = _data["encryptionKey"];
            this.firstName = _data["firstName"];
            this.hasAcceptedPrivacyPolicy = _data["hasAcceptedPrivacyPolicy"];
            this.hasAcceptedTerms = _data["hasAcceptedTerms"];
            this.isDeleted = _data["isDeleted"];
            this.isemailverified = _data["isemailverified"];
            this.lastName = _data["lastName"];
            this.mobile = _data["mobile"];
            this.name = _data["name"];
            this.password = _data["password"];
            this.verificationKey = _data["verificationKey"];
            this.verificationKeyExpiryTime = _data["verificationKeyExpiryTime"];
        }
    }

    static fromJS(data: any): AppUser {
        data = typeof data === 'object' ? data : {};
        let result = new AppUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["address"] = this.address;
        data["email"] = this.email;
        data["encryptionKey"] = this.encryptionKey;
        data["firstName"] = this.firstName;
        data["hasAcceptedPrivacyPolicy"] = this.hasAcceptedPrivacyPolicy;
        data["hasAcceptedTerms"] = this.hasAcceptedTerms;
        data["isDeleted"] = this.isDeleted;
        data["isemailverified"] = this.isemailverified;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["name"] = this.name;
        data["password"] = this.password;
        data["verificationKey"] = this.verificationKey;
        data["verificationKeyExpiryTime"] = this.verificationKeyExpiryTime;
        return data;
    }
}

export interface IAppUser {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    address?: string | undefined;
    email: string;
    encryptionKey?: string | undefined;
    firstName?: string | undefined;
    hasAcceptedPrivacyPolicy?: boolean;
    hasAcceptedTerms?: boolean;
    isDeleted?: boolean;
    isemailverified?: boolean;
    lastName?: string | undefined;
    mobile: string;
    name: string;
    password?: string | undefined;
    verificationKey?: string | undefined;
    verificationKeyExpiryTime?: string;
}

export class AppUserApiResponse implements IAppUserApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AppUser;
    hasError?: boolean;

    constructor(data?: IAppUserApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? AppUser.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AppUserApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAppUserApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AppUser;
    hasError?: boolean;
}

export class AppUserListApiResponse implements IAppUserListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AppUser[] | undefined;
    hasError?: boolean;

    constructor(data?: IAppUserListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AppUser.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AppUserListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAppUserListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AppUser[] | undefined;
    hasError?: boolean;
}

export class AppUserRole implements IAppUserRole {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
    appUserId?: number;
    roleId?: number;
    departmentId?: number;

    constructor(data?: IAppUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.appUserId = _data["appUserId"];
            this.roleId = _data["roleId"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): AppUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        data["appUserId"] = this.appUserId;
        data["roleId"] = this.roleId;
        data["departmentId"] = this.departmentId;
        return data;
    }
}

export interface IAppUserRole {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
    appUserId?: number;
    roleId?: number;
    departmentId?: number;
}

export class AppUserRoleDomainModel implements IAppUserRoleDomainModel {
    roleId?: number | undefined;
    name?: string | undefined;

    constructor(data?: IAppUserRoleDomainModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AppUserRoleDomainModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserRoleDomainModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["name"] = this.name;
        return data;
    }
}

export interface IAppUserRoleDomainModel {
    roleId?: number | undefined;
    name?: string | undefined;
}

export class AppUserRoleModel implements IAppUserRoleModel {
    appUserid?: number;
    appUserRoleDomainModel?: AppUserRoleDomainModel[] | undefined;

    constructor(data?: IAppUserRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appUserid = _data["appUserid"];
            if (Array.isArray(_data["appUserRoleDomainModel"])) {
                this.appUserRoleDomainModel = [] as any;
                for (let item of _data["appUserRoleDomainModel"])
                    this.appUserRoleDomainModel!.push(AppUserRoleDomainModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppUserRoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserRoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appUserid"] = this.appUserid;
        if (Array.isArray(this.appUserRoleDomainModel)) {
            data["appUserRoleDomainModel"] = [];
            for (let item of this.appUserRoleDomainModel)
                data["appUserRoleDomainModel"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppUserRoleModel {
    appUserid?: number;
    appUserRoleDomainModel?: AppUserRoleDomainModel[] | undefined;
}

export class Assessment implements IAssessment {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    metricGroupId?: string | undefined;
    name?: string | undefined;
    roleId?: number;
    serviceId?: number;
    templateId?: number;

    constructor(data?: IAssessment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.metricGroupId = _data["metricGroupId"];
            this.name = _data["name"];
            this.roleId = _data["roleId"];
            this.serviceId = _data["serviceId"];
            this.templateId = _data["templateId"];
        }
    }

    static fromJS(data: any): Assessment {
        data = typeof data === 'object' ? data : {};
        let result = new Assessment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["metricGroupId"] = this.metricGroupId;
        data["name"] = this.name;
        data["roleId"] = this.roleId;
        data["serviceId"] = this.serviceId;
        data["templateId"] = this.templateId;
        return data;
    }
}

export interface IAssessment {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    metricGroupId?: string | undefined;
    name?: string | undefined;
    roleId?: number;
    serviceId?: number;
    templateId?: number;
}

export class AssessmentDto implements IAssessmentDto {
    id?: number;
    assessmentName?: string | undefined;
    roleName?: string | undefined;
    metricgroupName?: string | undefined;
    serviceName?: string | undefined;
    templateId?: number | undefined;
    templateName?: string | undefined;

    constructor(data?: IAssessmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.assessmentName = _data["assessmentName"];
            this.roleName = _data["roleName"];
            this.metricgroupName = _data["metricgroupName"];
            this.serviceName = _data["serviceName"];
            this.templateId = _data["templateId"];
            this.templateName = _data["templateName"];
        }
    }

    static fromJS(data: any): AssessmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["assessmentName"] = this.assessmentName;
        data["roleName"] = this.roleName;
        data["metricgroupName"] = this.metricgroupName;
        data["serviceName"] = this.serviceName;
        data["templateId"] = this.templateId;
        data["templateName"] = this.templateName;
        return data;
    }
}

export interface IAssessmentDto {
    id?: number;
    assessmentName?: string | undefined;
    roleName?: string | undefined;
    metricgroupName?: string | undefined;
    serviceName?: string | undefined;
    templateId?: number | undefined;
    templateName?: string | undefined;
}

export class AssessmentDtoIEnumerableApiResponse implements IAssessmentDtoIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AssessmentDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IAssessmentDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssessmentDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AssessmentDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAssessmentDtoIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AssessmentDto[] | undefined;
    hasError?: boolean;
}

export class AssessmentIEnumerableApiResponse implements IAssessmentIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Assessment[] | undefined;
    hasError?: boolean;

    constructor(data?: IAssessmentIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Assessment.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AssessmentIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAssessmentIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Assessment[] | undefined;
    hasError?: boolean;
}

export class AssessmentStageDto implements IAssessmentStageDto {
    id?: number;
    roleId?: number;
    templateId?: number;
    templateName?: string | undefined;

    constructor(data?: IAssessmentStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.templateId = _data["templateId"];
            this.templateName = _data["templateName"];
        }
    }

    static fromJS(data: any): AssessmentStageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentStageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["templateId"] = this.templateId;
        data["templateName"] = this.templateName;
        return data;
    }
}

export interface IAssessmentStageDto {
    id?: number;
    roleId?: number;
    templateId?: number;
    templateName?: string | undefined;
}

export class AssessmentStageDtoListApiResponse implements IAssessmentStageDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AssessmentStageDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IAssessmentStageDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AssessmentStageDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AssessmentStageDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentStageDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAssessmentStageDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: AssessmentStageDto[] | undefined;
    hasError?: boolean;
}

export class AuditIssue implements IAuditIssue {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    auditId?: number | undefined;
    issueReason?: string | undefined;
    assignedTo?: number | undefined;
    startDate?: string;
    endDate?: string;
    issueStatus?: string | undefined;

    constructor(data?: IAuditIssue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.auditId = _data["auditId"];
            this.issueReason = _data["issueReason"];
            this.assignedTo = _data["assignedTo"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.issueStatus = _data["issueStatus"];
        }
    }

    static fromJS(data: any): AuditIssue {
        data = typeof data === 'object' ? data : {};
        let result = new AuditIssue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["auditId"] = this.auditId;
        data["issueReason"] = this.issueReason;
        data["assignedTo"] = this.assignedTo;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["issueStatus"] = this.issueStatus;
        return data;
    }
}

export interface IAuditIssue {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    auditId?: number | undefined;
    issueReason?: string | undefined;
    assignedTo?: number | undefined;
    startDate?: string;
    endDate?: string;
    issueStatus?: string | undefined;
}

export class Auditresponsedata implements IAuditresponsedata {
    responsejson?: string | undefined;

    constructor(data?: IAuditresponsedata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responsejson = _data["responsejson"];
        }
    }

    static fromJS(data: any): Auditresponsedata {
        data = typeof data === 'object' ? data : {};
        let result = new Auditresponsedata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responsejson"] = this.responsejson;
        return data;
    }
}

export interface IAuditresponsedata {
    responsejson?: string | undefined;
}

export class AuditresponsedataListApiResponse implements IAuditresponsedataListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Auditresponsedata[] | undefined;
    hasError?: boolean;

    constructor(data?: IAuditresponsedataListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Auditresponsedata.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): AuditresponsedataListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuditresponsedataListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IAuditresponsedataListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Auditresponsedata[] | undefined;
    hasError?: boolean;
}

export class B2CConfiguration implements IB2CConfiguration {
    loginDomain?: string | undefined;
    tenant?: string | undefined;
    loginFlow?: string | undefined;
    clientId?: string | undefined;
    resetPasswordFlow?: string | undefined;

    constructor(data?: IB2CConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginDomain = _data["loginDomain"];
            this.tenant = _data["tenant"];
            this.loginFlow = _data["loginFlow"];
            this.clientId = _data["clientId"];
            this.resetPasswordFlow = _data["resetPasswordFlow"];
        }
    }

    static fromJS(data: any): B2CConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new B2CConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginDomain"] = this.loginDomain;
        data["tenant"] = this.tenant;
        data["loginFlow"] = this.loginFlow;
        data["clientId"] = this.clientId;
        data["resetPasswordFlow"] = this.resetPasswordFlow;
        return data;
    }
}

export interface IB2CConfiguration {
    loginDomain?: string | undefined;
    tenant?: string | undefined;
    loginFlow?: string | undefined;
    clientId?: string | undefined;
    resetPasswordFlow?: string | undefined;
}

export class BooleanApiResponse implements IBooleanApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: boolean;
    hasError?: boolean;

    constructor(data?: IBooleanApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"];
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): BooleanApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IBooleanApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: boolean;
    hasError?: boolean;
}

export class BusinessUnits implements IBusinessUnits {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IBusinessUnits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): BusinessUnits {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IBusinessUnits {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class BusinessUnitsIEnumerableApiResponse implements IBusinessUnitsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: BusinessUnits[] | undefined;
    hasError?: boolean;

    constructor(data?: IBusinessUnitsIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BusinessUnits.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): BusinessUnitsIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUnitsIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IBusinessUnitsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: BusinessUnits[] | undefined;
    hasError?: boolean;
}

export class CalculationProcess implements ICalculationProcess {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    timeDimension?: number | undefined;
    formulaStandardId?: number | undefined;
    formulaInput?: number | undefined;
    formulaOutput?: string | undefined;
    metricId?: number | undefined;
    excelFormulae?: string | undefined;

    constructor(data?: ICalculationProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.timeDimension = _data["timeDimension"];
            this.formulaStandardId = _data["formulaStandardId"];
            this.formulaInput = _data["formulaInput"];
            this.formulaOutput = _data["formulaOutput"];
            this.metricId = _data["metricId"];
            this.excelFormulae = _data["excelFormulae"];
        }
    }

    static fromJS(data: any): CalculationProcess {
        data = typeof data === 'object' ? data : {};
        let result = new CalculationProcess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["timeDimension"] = this.timeDimension;
        data["formulaStandardId"] = this.formulaStandardId;
        data["formulaInput"] = this.formulaInput;
        data["formulaOutput"] = this.formulaOutput;
        data["metricId"] = this.metricId;
        data["excelFormulae"] = this.excelFormulae;
        return data;
    }
}

export interface ICalculationProcess {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    timeDimension?: number | undefined;
    formulaStandardId?: number | undefined;
    formulaInput?: number | undefined;
    formulaOutput?: string | undefined;
    metricId?: number | undefined;
    excelFormulae?: string | undefined;
}

export class CalculationProcessDto implements ICalculationProcessDto {
    id?: number | undefined;
    timeDimension?: number | undefined;
    formulaStandardId?: number | undefined;
    formulaStandardName?: string | undefined;
    formulaInput?: string | undefined;
    formulaOutput?: number | undefined;
    formulainputName?: string | undefined;
    formulaoutputName?: string | undefined;
    childQuestion?: string | undefined;
    childQuestionId?: number | undefined;

    constructor(data?: ICalculationProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.timeDimension = _data["timeDimension"];
            this.formulaStandardId = _data["formulaStandardId"];
            this.formulaStandardName = _data["formulaStandardName"];
            this.formulaInput = _data["formulaInput"];
            this.formulaOutput = _data["formulaOutput"];
            this.formulainputName = _data["formulainputName"];
            this.formulaoutputName = _data["formulaoutputName"];
            this.childQuestion = _data["childQuestion"];
            this.childQuestionId = _data["childQuestionId"];
        }
    }

    static fromJS(data: any): CalculationProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalculationProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timeDimension"] = this.timeDimension;
        data["formulaStandardId"] = this.formulaStandardId;
        data["formulaStandardName"] = this.formulaStandardName;
        data["formulaInput"] = this.formulaInput;
        data["formulaOutput"] = this.formulaOutput;
        data["formulainputName"] = this.formulainputName;
        data["formulaoutputName"] = this.formulaoutputName;
        data["childQuestion"] = this.childQuestion;
        data["childQuestionId"] = this.childQuestionId;
        return data;
    }
}

export interface ICalculationProcessDto {
    id?: number | undefined;
    timeDimension?: number | undefined;
    formulaStandardId?: number | undefined;
    formulaStandardName?: string | undefined;
    formulaInput?: string | undefined;
    formulaOutput?: number | undefined;
    formulainputName?: string | undefined;
    formulaoutputName?: string | undefined;
    childQuestion?: string | undefined;
    childQuestionId?: number | undefined;
}

export class CalculationProcessDtoIEnumerableApiResponse implements ICalculationProcessDtoIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: CalculationProcessDto[] | undefined;
    hasError?: boolean;

    constructor(data?: ICalculationProcessDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CalculationProcessDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): CalculationProcessDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CalculationProcessDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ICalculationProcessDtoIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: CalculationProcessDto[] | undefined;
    hasError?: boolean;
}

export class Category implements ICategory {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ICategory {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class CategoryIEnumerableApiResponse implements ICategoryIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Category[] | undefined;
    hasError?: boolean;

    constructor(data?: ICategoryIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Category.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): CategoryIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ICategoryIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Category[] | undefined;
    hasError?: boolean;
}

export class Cities implements ICities {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    code?: number;
    country?: string | undefined;
    state?: string | undefined;
    district?: string | undefined;
    zone?: string | undefined;
    city?: string | undefined;

    constructor(data?: ICities) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.code = _data["code"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.district = _data["district"];
            this.zone = _data["zone"];
            this.city = _data["city"];
        }
    }

    static fromJS(data: any): Cities {
        data = typeof data === 'object' ? data : {};
        let result = new Cities();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["code"] = this.code;
        data["country"] = this.country;
        data["state"] = this.state;
        data["district"] = this.district;
        data["zone"] = this.zone;
        data["city"] = this.city;
        return data;
    }
}

export interface ICities {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    code?: number;
    country?: string | undefined;
    state?: string | undefined;
    district?: string | undefined;
    zone?: string | undefined;
    city?: string | undefined;
}

export class Compliance implements ICompliance {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: ICompliance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Compliance {
        data = typeof data === 'object' ? data : {};
        let result = new Compliance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ICompliance {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class ComplianceIEnumerableApiResponse implements IComplianceIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Compliance[] | undefined;
    hasError?: boolean;

    constructor(data?: IComplianceIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Compliance.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ComplianceIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ComplianceIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IComplianceIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Compliance[] | undefined;
    hasError?: boolean;
}

export class ComplianceStageDto implements IComplianceStageDto {
    templateId?: number;
    templateName?: string | undefined;
    complianceId?: number;
    complianceName?: string | undefined;
    roleId?: number;
    processId?: number;
    auditingProcess?: number;
    auditName?: string | undefined;
    stageLevel?: number;
    auditId?: number | undefined;
    templatestageId?: number | undefined;
    status?: number;
    auditStatus?: number;
    periodId?: number;
    assessmentId?: number | undefined;
    reason?: string | undefined;
    issueReason?: string | undefined;
    metricGroupId?: number | undefined;

    constructor(data?: IComplianceStageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            this.templateName = _data["templateName"];
            this.complianceId = _data["complianceId"];
            this.complianceName = _data["complianceName"];
            this.roleId = _data["roleId"];
            this.processId = _data["processId"];
            this.auditingProcess = _data["auditingProcess"];
            this.auditName = _data["auditName"];
            this.stageLevel = _data["stageLevel"];
            this.auditId = _data["auditId"];
            this.templatestageId = _data["templatestageId"];
            this.status = _data["status"];
            this.auditStatus = _data["auditStatus"];
            this.periodId = _data["periodId"];
            this.assessmentId = _data["assessmentId"];
            this.reason = _data["reason"];
            this.issueReason = _data["issueReason"];
            this.metricGroupId = _data["metricGroupId"];
        }
    }

    static fromJS(data: any): ComplianceStageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComplianceStageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        data["templateName"] = this.templateName;
        data["complianceId"] = this.complianceId;
        data["complianceName"] = this.complianceName;
        data["roleId"] = this.roleId;
        data["processId"] = this.processId;
        data["auditingProcess"] = this.auditingProcess;
        data["auditName"] = this.auditName;
        data["stageLevel"] = this.stageLevel;
        data["auditId"] = this.auditId;
        data["templatestageId"] = this.templatestageId;
        data["status"] = this.status;
        data["auditStatus"] = this.auditStatus;
        data["periodId"] = this.periodId;
        data["assessmentId"] = this.assessmentId;
        data["reason"] = this.reason;
        data["issueReason"] = this.issueReason;
        data["metricGroupId"] = this.metricGroupId;
        return data;
    }
}

export interface IComplianceStageDto {
    templateId?: number;
    templateName?: string | undefined;
    complianceId?: number;
    complianceName?: string | undefined;
    roleId?: number;
    processId?: number;
    auditingProcess?: number;
    auditName?: string | undefined;
    stageLevel?: number;
    auditId?: number | undefined;
    templatestageId?: number | undefined;
    status?: number;
    auditStatus?: number;
    periodId?: number;
    assessmentId?: number | undefined;
    reason?: string | undefined;
    issueReason?: string | undefined;
    metricGroupId?: number | undefined;
}

export class ComplianceStageDtoListApiResponse implements IComplianceStageDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ComplianceStageDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IComplianceStageDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ComplianceStageDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ComplianceStageDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ComplianceStageDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IComplianceStageDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ComplianceStageDto[] | undefined;
    hasError?: boolean;
}

export class Createaudit implements ICreateaudit {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    startdate?: string;
    enddate?: string;
    requestedby?: number;
    auditingProcess?: number;
    name?: string | undefined;
    periodId?: number;
    assessmentGroup?: string | undefined;

    constructor(data?: ICreateaudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.startdate = _data["startdate"];
            this.enddate = _data["enddate"];
            this.requestedby = _data["requestedby"];
            this.auditingProcess = _data["auditingProcess"];
            this.name = _data["name"];
            this.periodId = _data["periodId"];
            this.assessmentGroup = _data["assessmentGroup"];
        }
    }

    static fromJS(data: any): Createaudit {
        data = typeof data === 'object' ? data : {};
        let result = new Createaudit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["startdate"] = this.startdate;
        data["enddate"] = this.enddate;
        data["requestedby"] = this.requestedby;
        data["auditingProcess"] = this.auditingProcess;
        data["name"] = this.name;
        data["periodId"] = this.periodId;
        data["assessmentGroup"] = this.assessmentGroup;
        return data;
    }
}

export interface ICreateaudit {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    startdate?: string;
    enddate?: string;
    requestedby?: number;
    auditingProcess?: number;
    name?: string | undefined;
    periodId?: number;
    assessmentGroup?: string | undefined;
}

export class CreateauditDto implements ICreateauditDto {
    startdate?: string;
    enddate?: string;
    requestedby?: number;
    auditingProcess?: number;
    name?: string | undefined;
    periodId?: number;
    assessmentGroup?: string | undefined;
    assessmentGroupName?: string | undefined;
    id?: number | undefined;

    constructor(data?: ICreateauditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startdate = _data["startdate"];
            this.enddate = _data["enddate"];
            this.requestedby = _data["requestedby"];
            this.auditingProcess = _data["auditingProcess"];
            this.name = _data["name"];
            this.periodId = _data["periodId"];
            this.assessmentGroup = _data["assessmentGroup"];
            this.assessmentGroupName = _data["assessmentGroupName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateauditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateauditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startdate"] = this.startdate;
        data["enddate"] = this.enddate;
        data["requestedby"] = this.requestedby;
        data["auditingProcess"] = this.auditingProcess;
        data["name"] = this.name;
        data["periodId"] = this.periodId;
        data["assessmentGroup"] = this.assessmentGroup;
        data["assessmentGroupName"] = this.assessmentGroupName;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateauditDto {
    startdate?: string;
    enddate?: string;
    requestedby?: number;
    auditingProcess?: number;
    name?: string | undefined;
    periodId?: number;
    assessmentGroup?: string | undefined;
    assessmentGroupName?: string | undefined;
    id?: number | undefined;
}

export class CreateauditDtoListApiResponse implements ICreateauditDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: CreateauditDto[] | undefined;
    hasError?: boolean;

    constructor(data?: ICreateauditDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CreateauditDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): CreateauditDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateauditDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ICreateauditDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: CreateauditDto[] | undefined;
    hasError?: boolean;
}

export class CreateauditListApiResponse implements ICreateauditListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Createaudit[] | undefined;
    hasError?: boolean;

    constructor(data?: ICreateauditListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Createaudit.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): CreateauditListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateauditListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ICreateauditListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Createaudit[] | undefined;
    hasError?: boolean;
}

export class Currency implements ICurrency {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ICurrency {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class CurrencyIEnumerableApiResponse implements ICurrencyIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Currency[] | undefined;
    hasError?: boolean;

    constructor(data?: ICurrencyIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Currency.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): CurrencyIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ICurrencyIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Currency[] | undefined;
    hasError?: boolean;
}

export class Dataingestion implements IDataingestion {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    timeDimension?: number | undefined;
    uom?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    conversionformulae?: string | undefined;
    metricgroupId?: number | undefined;
    calculatedjson?: { [key: string]: any; } | undefined;
    timeDimensionData?: { [key: string]: any; } | undefined;
    month?: number | undefined;
    year?: number | undefined;
    total?: { [key: string]: any; } | undefined;

    constructor(data?: IDataingestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.timeDimension = _data["timeDimension"];
            this.uom = _data["uom"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.conversionformulae = _data["conversionformulae"];
            this.metricgroupId = _data["metricgroupId"];
            if (_data["calculatedjson"]) {
                this.calculatedjson = {} as any;
                for (let key in _data["calculatedjson"]) {
                    if (_data["calculatedjson"].hasOwnProperty(key))
                        (<any>this.calculatedjson)![key] = _data["calculatedjson"][key];
                }
            }
            if (_data["timeDimensionData"]) {
                this.timeDimensionData = {} as any;
                for (let key in _data["timeDimensionData"]) {
                    if (_data["timeDimensionData"].hasOwnProperty(key))
                        (<any>this.timeDimensionData)![key] = _data["timeDimensionData"][key];
                }
            }
            this.month = _data["month"];
            this.year = _data["year"];
            if (_data["total"]) {
                this.total = {} as any;
                for (let key in _data["total"]) {
                    if (_data["total"].hasOwnProperty(key))
                        (<any>this.total)![key] = _data["total"][key];
                }
            }
        }
    }

    static fromJS(data: any): Dataingestion {
        data = typeof data === 'object' ? data : {};
        let result = new Dataingestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["timeDimension"] = this.timeDimension;
        data["uom"] = this.uom;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["conversionformulae"] = this.conversionformulae;
        data["metricgroupId"] = this.metricgroupId;
        if (this.calculatedjson) {
            data["calculatedjson"] = {};
            for (let key in this.calculatedjson) {
                if (this.calculatedjson.hasOwnProperty(key))
                    (<any>data["calculatedjson"])[key] = (<any>this.calculatedjson)[key];
            }
        }
        if (this.timeDimensionData) {
            data["timeDimensionData"] = {};
            for (let key in this.timeDimensionData) {
                if (this.timeDimensionData.hasOwnProperty(key))
                    (<any>data["timeDimensionData"])[key] = (<any>this.timeDimensionData)[key];
            }
        }
        data["month"] = this.month;
        data["year"] = this.year;
        if (this.total) {
            data["total"] = {};
            for (let key in this.total) {
                if (this.total.hasOwnProperty(key))
                    (<any>data["total"])[key] = (<any>this.total)[key];
            }
        }
        return data;
    }
}

export interface IDataingestion {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    timeDimension?: number | undefined;
    uom?: number | undefined;
    data?: { [key: string]: any; } | undefined;
    conversionformulae?: string | undefined;
    metricgroupId?: number | undefined;
    calculatedjson?: { [key: string]: any; } | undefined;
    timeDimensionData?: { [key: string]: any; } | undefined;
    month?: number | undefined;
    year?: number | undefined;
    total?: { [key: string]: any; } | undefined;
}

export class DataingestionListApiResponse implements IDataingestionListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Dataingestion[] | undefined;
    hasError?: boolean;

    constructor(data?: IDataingestionListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Dataingestion.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): DataingestionListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataingestionListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IDataingestionListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Dataingestion[] | undefined;
    hasError?: boolean;
}

export class DataviewDimensions implements IDataviewDimensions {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IDataviewDimensions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): DataviewDimensions {
        data = typeof data === 'object' ? data : {};
        let result = new DataviewDimensions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IDataviewDimensions {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class DataviewDimensionsIEnumerableApiResponse implements IDataviewDimensionsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: DataviewDimensions[] | undefined;
    hasError?: boolean;

    constructor(data?: IDataviewDimensionsIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(DataviewDimensions.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): DataviewDimensionsIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DataviewDimensionsIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IDataviewDimensionsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: DataviewDimensions[] | undefined;
    hasError?: boolean;
}

export class Department implements IDepartment {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IDepartment {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class DepartmentIEnumerableApiResponse implements IDepartmentIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Department[] | undefined;
    hasError?: boolean;

    constructor(data?: IDepartmentIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Department.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): DepartmentIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IDepartmentIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Department[] | undefined;
    hasError?: boolean;
}

export class EmailContentModel implements IEmailContentModel {
    userId?: number;
    emailcontent?: string | undefined;
    createdDate?: string;

    constructor(data?: IEmailContentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.emailcontent = _data["emailcontent"];
            this.createdDate = _data["createdDate"];
        }
    }

    static fromJS(data: any): EmailContentModel {
        data = typeof data === 'object' ? data : {};
        let result = new EmailContentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["emailcontent"] = this.emailcontent;
        data["createdDate"] = this.createdDate;
        return data;
    }
}

export interface IEmailContentModel {
    userId?: number;
    emailcontent?: string | undefined;
    createdDate?: string;
}

export class EmailContentModelApiResponse implements IEmailContentModelApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: EmailContentModel;
    hasError?: boolean;

    constructor(data?: IEmailContentModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? EmailContentModel.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): EmailContentModelApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmailContentModelApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IEmailContentModelApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: EmailContentModel;
    hasError?: boolean;
}

export class EsgrcType implements IEsgrcType {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IEsgrcType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): EsgrcType {
        data = typeof data === 'object' ? data : {};
        let result = new EsgrcType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IEsgrcType {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class EsgrcTypeIEnumerableApiResponse implements IEsgrcTypeIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: EsgrcType[] | undefined;
    hasError?: boolean;

    constructor(data?: IEsgrcTypeIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EsgrcType.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): EsgrcTypeIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EsgrcTypeIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IEsgrcTypeIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: EsgrcType[] | undefined;
    hasError?: boolean;
}

export class Facility implements IFacility {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IFacility) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Facility {
        data = typeof data === 'object' ? data : {};
        let result = new Facility();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IFacility {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class FacilityIEnumerableApiResponse implements IFacilityIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Facility[] | undefined;
    hasError?: boolean;

    constructor(data?: IFacilityIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Facility.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): FacilityIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FacilityIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IFacilityIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Facility[] | undefined;
    hasError?: boolean;
}

export class FiscalYear implements IFiscalYear {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    year?: number;
    startMonth?: string | undefined;
    endMonth?: string | undefined;

    constructor(data?: IFiscalYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.year = _data["year"];
            this.startMonth = _data["startMonth"];
            this.endMonth = _data["endMonth"];
        }
    }

    static fromJS(data: any): FiscalYear {
        data = typeof data === 'object' ? data : {};
        let result = new FiscalYear();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["year"] = this.year;
        data["startMonth"] = this.startMonth;
        data["endMonth"] = this.endMonth;
        return data;
    }
}

export interface IFiscalYear {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    year?: number;
    startMonth?: string | undefined;
    endMonth?: string | undefined;
}

export class FiscalYearListApiResponse implements IFiscalYearListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: FiscalYear[] | undefined;
    hasError?: boolean;

    constructor(data?: IFiscalYearListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(FiscalYear.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): FiscalYearListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FiscalYearListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IFiscalYearListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: FiscalYear[] | undefined;
    hasError?: boolean;
}

export class FormulaStandards implements IFormulaStandards {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IFormulaStandards) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): FormulaStandards {
        data = typeof data === 'object' ? data : {};
        let result = new FormulaStandards();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IFormulaStandards {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class FormulaStandardsIEnumerableApiResponse implements IFormulaStandardsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: FormulaStandards[] | undefined;
    hasError?: boolean;

    constructor(data?: IFormulaStandardsIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(FormulaStandards.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): FormulaStandardsIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FormulaStandardsIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IFormulaStandardsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: FormulaStandards[] | undefined;
    hasError?: boolean;
}

export class GeoGraphy implements IGeoGraphy {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    locationtypeId?: number;
    parentId?: number;
    type_Name?: string | undefined;

    constructor(data?: IGeoGraphy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.locationtypeId = _data["locationtypeId"];
            this.parentId = _data["parentId"];
            this.type_Name = _data["type_Name"];
        }
    }

    static fromJS(data: any): GeoGraphy {
        data = typeof data === 'object' ? data : {};
        let result = new GeoGraphy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["locationtypeId"] = this.locationtypeId;
        data["parentId"] = this.parentId;
        data["type_Name"] = this.type_Name;
        return data;
    }
}

export interface IGeoGraphy {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    locationtypeId?: number;
    parentId?: number;
    type_Name?: string | undefined;
}

export class GeoGraphyIEnumerableApiResponse implements IGeoGraphyIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GeoGraphy[] | undefined;
    hasError?: boolean;

    constructor(data?: IGeoGraphyIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GeoGraphy.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): GeoGraphyIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GeoGraphyIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IGeoGraphyIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GeoGraphy[] | undefined;
    hasError?: boolean;
}

export class GetMetricDetailsModel implements IGetMetricDetailsModel {
    metric?: string | undefined;
    datatype?: string | undefined;
    createdby?: string | undefined;

    constructor(data?: IGetMetricDetailsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metric = _data["metric"];
            this.datatype = _data["datatype"];
            this.createdby = _data["createdby"];
        }
    }

    static fromJS(data: any): GetMetricDetailsModel {
        data = typeof data === 'object' ? data : {};
        let result = new GetMetricDetailsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metric"] = this.metric;
        data["datatype"] = this.datatype;
        data["createdby"] = this.createdby;
        return data;
    }
}

export interface IGetMetricDetailsModel {
    metric?: string | undefined;
    datatype?: string | undefined;
    createdby?: string | undefined;
}

export class GetMetricDetailsModelListApiResponse implements IGetMetricDetailsModelListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GetMetricDetailsModel[] | undefined;
    hasError?: boolean;

    constructor(data?: IGetMetricDetailsModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GetMetricDetailsModel.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): GetMetricDetailsModelListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMetricDetailsModelListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IGetMetricDetailsModelListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GetMetricDetailsModel[] | undefined;
    hasError?: boolean;
}

export class GetMetricGroup implements IGetMetricGroup {
    label?: string | undefined;
    name?: string | undefined;
    metricCount?: number | undefined;
    groupId?: number;
    complianceId?: number | undefined;
    industry?: number | undefined;
    industryName?: string | undefined;
    regulationtypeid?: number;
    regulationCount?: number | undefined;
    parentId?: number | undefined;
    isHierarchy?: boolean | undefined;

    constructor(data?: IGetMetricGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.name = _data["name"];
            this.metricCount = _data["metricCount"];
            this.groupId = _data["groupId"];
            this.complianceId = _data["complianceId"];
            this.industry = _data["industry"];
            this.industryName = _data["industryName"];
            this.regulationtypeid = _data["regulationtypeid"];
            this.regulationCount = _data["regulationCount"];
            this.parentId = _data["parentId"];
            this.isHierarchy = _data["isHierarchy"];
        }
    }

    static fromJS(data: any): GetMetricGroup {
        data = typeof data === 'object' ? data : {};
        let result = new GetMetricGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["name"] = this.name;
        data["metricCount"] = this.metricCount;
        data["groupId"] = this.groupId;
        data["complianceId"] = this.complianceId;
        data["industry"] = this.industry;
        data["industryName"] = this.industryName;
        data["regulationtypeid"] = this.regulationtypeid;
        data["regulationCount"] = this.regulationCount;
        data["parentId"] = this.parentId;
        data["isHierarchy"] = this.isHierarchy;
        return data;
    }
}

export interface IGetMetricGroup {
    label?: string | undefined;
    name?: string | undefined;
    metricCount?: number | undefined;
    groupId?: number;
    complianceId?: number | undefined;
    industry?: number | undefined;
    industryName?: string | undefined;
    regulationtypeid?: number;
    regulationCount?: number | undefined;
    parentId?: number | undefined;
    isHierarchy?: boolean | undefined;
}

export class GetMetricGroupListApiResponse implements IGetMetricGroupListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GetMetricGroup[] | undefined;
    hasError?: boolean;

    constructor(data?: IGetMetricGroupListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GetMetricGroup.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): GetMetricGroupListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMetricGroupListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IGetMetricGroupListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GetMetricGroup[] | undefined;
    hasError?: boolean;
}

export class GoalSetting implements IGoalSetting {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    updatedBy?: number;
    isActive?: boolean;
    id?: number;
    name?: string | undefined;
    yearId?: number | undefined;
    targetJson?: string | undefined;
    uploadedFileid?: number;

    constructor(data?: IGoalSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.yearId = _data["yearId"];
            this.targetJson = _data["targetJson"];
            this.uploadedFileid = _data["uploadedFileid"];
        }
    }

    static fromJS(data: any): GoalSetting {
        data = typeof data === 'object' ? data : {};
        let result = new GoalSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        data["name"] = this.name;
        data["yearId"] = this.yearId;
        data["targetJson"] = this.targetJson;
        data["uploadedFileid"] = this.uploadedFileid;
        return data;
    }
}

export interface IGoalSetting {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    updatedBy?: number;
    isActive?: boolean;
    id?: number;
    name?: string | undefined;
    yearId?: number | undefined;
    targetJson?: string | undefined;
    uploadedFileid?: number;
}

export class GoalSettingDto implements IGoalSettingDto {
    id?: number;
    name?: string | undefined;
    yearId?: number;
    yearName?: string | undefined;
    targetJson?: { [key: string]: any; } | undefined;

    constructor(data?: IGoalSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.yearId = _data["yearId"];
            this.yearName = _data["yearName"];
            if (_data["targetJson"]) {
                this.targetJson = {} as any;
                for (let key in _data["targetJson"]) {
                    if (_data["targetJson"].hasOwnProperty(key))
                        (<any>this.targetJson)![key] = _data["targetJson"][key];
                }
            }
        }
    }

    static fromJS(data: any): GoalSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoalSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["yearId"] = this.yearId;
        data["yearName"] = this.yearName;
        if (this.targetJson) {
            data["targetJson"] = {};
            for (let key in this.targetJson) {
                if (this.targetJson.hasOwnProperty(key))
                    (<any>data["targetJson"])[key] = (<any>this.targetJson)[key];
            }
        }
        return data;
    }
}

export interface IGoalSettingDto {
    id?: number;
    name?: string | undefined;
    yearId?: number;
    yearName?: string | undefined;
    targetJson?: { [key: string]: any; } | undefined;
}

export class GoalSettingDtoListApiResponse implements IGoalSettingDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GoalSettingDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IGoalSettingDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GoalSettingDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): GoalSettingDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GoalSettingDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IGoalSettingDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GoalSettingDto[] | undefined;
    hasError?: boolean;
}

export class GoalSettingListApiResponse implements IGoalSettingListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GoalSetting[] | undefined;
    hasError?: boolean;

    constructor(data?: IGoalSettingListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(GoalSetting.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): GoalSettingListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GoalSettingListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IGoalSettingListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: GoalSetting[] | undefined;
    hasError?: boolean;
}

export class HyperlinkEdit implements IHyperlinkEdit {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    updatedBy?: number;
    isActive?: boolean;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    id?: number;
    address?: string | undefined;

    constructor(data?: IHyperlinkEdit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.id = _data["id"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): HyperlinkEdit {
        data = typeof data === 'object' ? data : {};
        let result = new HyperlinkEdit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["id"] = this.id;
        data["address"] = this.address;
        return data;
    }
}

export interface IHyperlinkEdit {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    updatedBy?: number;
    isActive?: boolean;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    id?: number;
    address?: string | undefined;
}

export class IEnumerableApiResponse implements IIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: any[] | undefined;
    hasError?: boolean;

    constructor(data?: IIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): IEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: any[] | undefined;
    hasError?: boolean;
}

export class Industry implements IIndustry {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IIndustry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Industry {
        data = typeof data === 'object' ? data : {};
        let result = new Industry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IIndustry {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class IndustryIEnumerableApiResponse implements IIndustryIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Industry[] | undefined;
    hasError?: boolean;

    constructor(data?: IIndustryIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Industry.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): IndustryIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IndustryIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IIndustryIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Industry[] | undefined;
    hasError?: boolean;
}

export class Int32ApiResponse implements IInt32ApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: number;
    hasError?: boolean;

    constructor(data?: IInt32ApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"];
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): Int32ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int32ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IInt32ApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: number;
    hasError?: boolean;
}

export class Int64ApiResponse implements IInt64ApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: number;
    hasError?: boolean;

    constructor(data?: IInt64ApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"];
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): Int64ApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int64ApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IInt64ApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: number;
    hasError?: boolean;
}

export class Int64ListApiResponse implements IInt64ListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: number[] | undefined;
    hasError?: boolean;

    constructor(data?: IInt64ListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): Int64ListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int64ListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IInt64ListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: number[] | undefined;
    hasError?: boolean;
}

export enum IsActiveFilter {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class LabelModel implements ILabelModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    language?: string | undefined;
    languageId?: number;
    isActive?: boolean;

    constructor(data?: ILabelModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.language = _data["language"];
            this.languageId = _data["languageId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): LabelModel {
        data = typeof data === 'object' ? data : {};
        let result = new LabelModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["language"] = this.language;
        data["languageId"] = this.languageId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ILabelModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    language?: string | undefined;
    languageId?: number;
    isActive?: boolean;
}

export class LabelModelIEnumerableApiResponse implements ILabelModelIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: LabelModel[] | undefined;
    hasError?: boolean;

    constructor(data?: ILabelModelIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(LabelModel.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): LabelModelIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LabelModelIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ILabelModelIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: LabelModel[] | undefined;
    hasError?: boolean;
}

export class LabelModelSearchResult implements ILabelModelSearchResult {
    totalNoOfRecords?: number;
    records?: LabelModel[] | undefined;

    constructor(data?: ILabelModelSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalNoOfRecords = _data["totalNoOfRecords"];
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(LabelModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LabelModelSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new LabelModelSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalNoOfRecords"] = this.totalNoOfRecords;
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILabelModelSearchResult {
    totalNoOfRecords?: number;
    records?: LabelModel[] | undefined;
}

export class LabelModelSearchResultApiResponse implements ILabelModelSearchResultApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: LabelModelSearchResult;
    hasError?: boolean;

    constructor(data?: ILabelModelSearchResultApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? LabelModelSearchResult.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): LabelModelSearchResultApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LabelModelSearchResultApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ILabelModelSearchResultApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: LabelModelSearchResult;
    hasError?: boolean;
}

export class Language implements ILanguage {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ILanguage {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class LanguageIEnumerableApiResponse implements ILanguageIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Language[] | undefined;
    hasError?: boolean;

    constructor(data?: ILanguageIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Language.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): LanguageIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ILanguageIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Language[] | undefined;
    hasError?: boolean;
}

export class LoginViewModel implements ILoginViewModel {
    email?: string | undefined;
    password?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    token?: string | undefined;
    ipAddress?: string | undefined;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.token = _data["token"];
            this.ipAddress = _data["ipAddress"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["token"] = this.token;
        data["ipAddress"] = this.ipAddress;
        return data;
    }
}

export interface ILoginViewModel {
    email?: string | undefined;
    password?: string | undefined;
    latitude?: number | undefined;
    longitude?: number | undefined;
    token?: string | undefined;
    ipAddress?: string | undefined;
}

export class MeModel implements IMeModel {
    id?: number;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    roleId?: number[] | undefined;
    genderId?: number;
    isActive?: boolean;
    isemailverified?: boolean;
    hasActivationRequest?: boolean;
    dateCreated?: string;
    dateModified?: string;
    hasProfilePicture?: boolean;
    readonly profilePictureUrl?: string | undefined;
    lastLoginDate?: string | undefined;
    lastLoginLocation?: string | undefined;
    tenantId?: number | undefined;

    constructor(data?: IMeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.zip = _data["zip"];
            this.city = _data["city"];
            this.address = _data["address"];
            if (Array.isArray(_data["roleId"])) {
                this.roleId = [] as any;
                for (let item of _data["roleId"])
                    this.roleId!.push(item);
            }
            this.genderId = _data["genderId"];
            this.isActive = _data["isActive"];
            this.isemailverified = _data["isemailverified"];
            this.hasActivationRequest = _data["hasActivationRequest"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.hasProfilePicture = _data["hasProfilePicture"];
            (<any>this).profilePictureUrl = _data["profilePictureUrl"];
            this.lastLoginDate = _data["lastLoginDate"];
            this.lastLoginLocation = _data["lastLoginLocation"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): MeModel {
        data = typeof data === 'object' ? data : {};
        let result = new MeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["country"] = this.country;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["city"] = this.city;
        data["address"] = this.address;
        if (Array.isArray(this.roleId)) {
            data["roleId"] = [];
            for (let item of this.roleId)
                data["roleId"].push(item);
        }
        data["genderId"] = this.genderId;
        data["isActive"] = this.isActive;
        data["isemailverified"] = this.isemailverified;
        data["hasActivationRequest"] = this.hasActivationRequest;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["hasProfilePicture"] = this.hasProfilePicture;
        data["profilePictureUrl"] = this.profilePictureUrl;
        data["lastLoginDate"] = this.lastLoginDate;
        data["lastLoginLocation"] = this.lastLoginLocation;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IMeModel {
    id?: number;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    mobile?: string | undefined;
    email?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    roleId?: number[] | undefined;
    genderId?: number;
    isActive?: boolean;
    isemailverified?: boolean;
    hasActivationRequest?: boolean;
    dateCreated?: string;
    dateModified?: string;
    hasProfilePicture?: boolean;
    profilePictureUrl?: string | undefined;
    lastLoginDate?: string | undefined;
    lastLoginLocation?: string | undefined;
    tenantId?: number | undefined;
}

export class MeModelApiResponse implements IMeModelApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MeModel;
    hasError?: boolean;

    constructor(data?: IMeModelApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? MeModel.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MeModelApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MeModelApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMeModelApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MeModel;
    hasError?: boolean;
}

export class MergeReport implements IMergeReport {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    pdfId?: string | undefined;

    constructor(data?: IMergeReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.pdfId = _data["pdfId"];
        }
    }

    static fromJS(data: any): MergeReport {
        data = typeof data === 'object' ? data : {};
        let result = new MergeReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["description"] = this.description;
        data["pdfId"] = this.pdfId;
        return data;
    }
}

export interface IMergeReport {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    pdfId?: string | undefined;
}

export class MergeReportDto implements IMergeReportDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    pdfId?: string | undefined;
    pdfName?: string | undefined;
    reportId?: number;
    pageNumber?: number;
    type?: string | undefined;
    guid?: string | undefined;
    urlName?: string | undefined;

    constructor(data?: IMergeReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.pdfId = _data["pdfId"];
            this.pdfName = _data["pdfName"];
            this.reportId = _data["reportId"];
            this.pageNumber = _data["pageNumber"];
            this.type = _data["type"];
            this.guid = _data["guid"];
            this.urlName = _data["urlName"];
        }
    }

    static fromJS(data: any): MergeReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new MergeReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["pdfId"] = this.pdfId;
        data["pdfName"] = this.pdfName;
        data["reportId"] = this.reportId;
        data["pageNumber"] = this.pageNumber;
        data["type"] = this.type;
        data["guid"] = this.guid;
        data["urlName"] = this.urlName;
        return data;
    }
}

export interface IMergeReportDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    pdfId?: string | undefined;
    pdfName?: string | undefined;
    reportId?: number;
    pageNumber?: number;
    type?: string | undefined;
    guid?: string | undefined;
    urlName?: string | undefined;
}

export class MergeReportDtoListApiResponse implements IMergeReportDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MergeReportDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IMergeReportDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MergeReportDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MergeReportDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MergeReportDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMergeReportDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MergeReportDto[] | undefined;
    hasError?: boolean;
}

export class Metric implements IMetric {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    displayLabel?: string | undefined;
    typeId?: number | undefined;
    groupId?: number | undefined;
    validationId?: string | undefined;
    metricsQuestion?: string | undefined;
    lookupTable?: string | undefined;
    lookupTableColumn?: string | undefined;
    esgrcType?: number | undefined;
    uom?: number | undefined;
    category?: number | undefined;
    standard?: number | undefined;
    department?: number | undefined;
    isKeyIndicator?: boolean | undefined;
    target?: string | undefined;
    standardYear?: string | undefined;
    serviceid?: number;
    parentid?: number | undefined;
    regulationtypeid?: number;
    isunique?: boolean;
    timeDimension?: number | undefined;
    formulaeField?: string | undefined;
    prefix?: number | undefined;

    constructor(data?: IMetric) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.displayLabel = _data["displayLabel"];
            this.typeId = _data["typeId"];
            this.groupId = _data["groupId"];
            this.validationId = _data["validationId"];
            this.metricsQuestion = _data["metricsQuestion"];
            this.lookupTable = _data["lookupTable"];
            this.lookupTableColumn = _data["lookupTableColumn"];
            this.esgrcType = _data["esgrcType"];
            this.uom = _data["uom"];
            this.category = _data["category"];
            this.standard = _data["standard"];
            this.department = _data["department"];
            this.isKeyIndicator = _data["isKeyIndicator"];
            this.target = _data["target"];
            this.standardYear = _data["standardYear"];
            this.serviceid = _data["serviceid"];
            this.parentid = _data["parentid"];
            this.regulationtypeid = _data["regulationtypeid"];
            this.isunique = _data["isunique"];
            this.timeDimension = _data["timeDimension"];
            this.formulaeField = _data["formulaeField"];
            this.prefix = _data["prefix"];
        }
    }

    static fromJS(data: any): Metric {
        data = typeof data === 'object' ? data : {};
        let result = new Metric();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["displayLabel"] = this.displayLabel;
        data["typeId"] = this.typeId;
        data["groupId"] = this.groupId;
        data["validationId"] = this.validationId;
        data["metricsQuestion"] = this.metricsQuestion;
        data["lookupTable"] = this.lookupTable;
        data["lookupTableColumn"] = this.lookupTableColumn;
        data["esgrcType"] = this.esgrcType;
        data["uom"] = this.uom;
        data["category"] = this.category;
        data["standard"] = this.standard;
        data["department"] = this.department;
        data["isKeyIndicator"] = this.isKeyIndicator;
        data["target"] = this.target;
        data["standardYear"] = this.standardYear;
        data["serviceid"] = this.serviceid;
        data["parentid"] = this.parentid;
        data["regulationtypeid"] = this.regulationtypeid;
        data["isunique"] = this.isunique;
        data["timeDimension"] = this.timeDimension;
        data["formulaeField"] = this.formulaeField;
        data["prefix"] = this.prefix;
        return data;
    }
}

export interface IMetric {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    displayLabel?: string | undefined;
    typeId?: number | undefined;
    groupId?: number | undefined;
    validationId?: string | undefined;
    metricsQuestion?: string | undefined;
    lookupTable?: string | undefined;
    lookupTableColumn?: string | undefined;
    esgrcType?: number | undefined;
    uom?: number | undefined;
    category?: number | undefined;
    standard?: number | undefined;
    department?: number | undefined;
    isKeyIndicator?: boolean | undefined;
    target?: string | undefined;
    standardYear?: string | undefined;
    serviceid?: number;
    parentid?: number | undefined;
    regulationtypeid?: number;
    isunique?: boolean;
    timeDimension?: number | undefined;
    formulaeField?: string | undefined;
    prefix?: number | undefined;
}

export class MetricAnswerOptionDto implements IMetricAnswerOptionDto {
    id?: number;
    responseJson?: { [key: string]: any; } | undefined;
    templateId?: number | undefined;
    metricGroupId?: number | undefined;
    processId?: number;
    status?: number | undefined;
    auditId?: number;
    assessmentId?: number | undefined;
    uploadedFileId?: number | undefined;

    constructor(data?: IMetricAnswerOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["responseJson"]) {
                this.responseJson = {} as any;
                for (let key in _data["responseJson"]) {
                    if (_data["responseJson"].hasOwnProperty(key))
                        (<any>this.responseJson)![key] = _data["responseJson"][key];
                }
            }
            this.templateId = _data["templateId"];
            this.metricGroupId = _data["metricGroupId"];
            this.processId = _data["processId"];
            this.status = _data["status"];
            this.auditId = _data["auditId"];
            this.assessmentId = _data["assessmentId"];
            this.uploadedFileId = _data["uploadedFileId"];
        }
    }

    static fromJS(data: any): MetricAnswerOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetricAnswerOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.responseJson) {
            data["responseJson"] = {};
            for (let key in this.responseJson) {
                if (this.responseJson.hasOwnProperty(key))
                    (<any>data["responseJson"])[key] = (<any>this.responseJson)[key];
            }
        }
        data["templateId"] = this.templateId;
        data["metricGroupId"] = this.metricGroupId;
        data["processId"] = this.processId;
        data["status"] = this.status;
        data["auditId"] = this.auditId;
        data["assessmentId"] = this.assessmentId;
        data["uploadedFileId"] = this.uploadedFileId;
        return data;
    }
}

export interface IMetricAnswerOptionDto {
    id?: number;
    responseJson?: { [key: string]: any; } | undefined;
    templateId?: number | undefined;
    metricGroupId?: number | undefined;
    processId?: number;
    status?: number | undefined;
    auditId?: number;
    assessmentId?: number | undefined;
    uploadedFileId?: number | undefined;
}

export class MetricAnswerOptions implements IMetricAnswerOptions {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    responseJson?: { [key: string]: any; } | undefined;
    templateId?: number | undefined;
    assessmentId?: number | undefined;
    metricGroupId?: number | undefined;
    processId?: number;
    status?: number | undefined;
    auditId?: number | undefined;
    uploadedFileId?: number | undefined;

    constructor(data?: IMetricAnswerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            if (_data["responseJson"]) {
                this.responseJson = {} as any;
                for (let key in _data["responseJson"]) {
                    if (_data["responseJson"].hasOwnProperty(key))
                        (<any>this.responseJson)![key] = _data["responseJson"][key];
                }
            }
            this.templateId = _data["templateId"];
            this.assessmentId = _data["assessmentId"];
            this.metricGroupId = _data["metricGroupId"];
            this.processId = _data["processId"];
            this.status = _data["status"];
            this.auditId = _data["auditId"];
            this.uploadedFileId = _data["uploadedFileId"];
        }
    }

    static fromJS(data: any): MetricAnswerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new MetricAnswerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        if (this.responseJson) {
            data["responseJson"] = {};
            for (let key in this.responseJson) {
                if (this.responseJson.hasOwnProperty(key))
                    (<any>data["responseJson"])[key] = (<any>this.responseJson)[key];
            }
        }
        data["templateId"] = this.templateId;
        data["assessmentId"] = this.assessmentId;
        data["metricGroupId"] = this.metricGroupId;
        data["processId"] = this.processId;
        data["status"] = this.status;
        data["auditId"] = this.auditId;
        data["uploadedFileId"] = this.uploadedFileId;
        return data;
    }
}

export interface IMetricAnswerOptions {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    responseJson?: { [key: string]: any; } | undefined;
    templateId?: number | undefined;
    assessmentId?: number | undefined;
    metricGroupId?: number | undefined;
    processId?: number;
    status?: number | undefined;
    auditId?: number | undefined;
    uploadedFileId?: number | undefined;
}

export class MetricAnswerOptionsListApiResponse implements IMetricAnswerOptionsListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricAnswerOptions[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricAnswerOptionsListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MetricAnswerOptions.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricAnswerOptionsListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricAnswerOptionsListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricAnswerOptionsListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricAnswerOptions[] | undefined;
    hasError?: boolean;
}

export class MetricDomainModel implements IMetricDomainModel {
    id?: number | undefined;
    name?: string | undefined;
    displayLabel?: string | undefined;
    typeId?: number;
    groupId?: number;
    metrictypeId?: number;
    typeName?: string | undefined;
    validationId?: string | undefined;
    validationName?: string | undefined;
    lookupTable?: string | undefined;
    lookupTableColumn?: string | undefined;
    metricsQuestion?: string | undefined;
    esgrcType?: number;
    esgrcName?: string | undefined;
    uom?: number;
    uomName?: string | undefined;
    category?: number;
    categoryName?: string | undefined;
    standard?: number;
    standardName?: string | undefined;
    departmentid?: number;
    departmentName?: string | undefined;
    target?: string | undefined;
    standardYear?: string | undefined;
    serviceid?: number;
    parentid?: number | undefined;
    regulationtypeid?: number;
    isKeyIndicator?: boolean;
    serviceName?: string | undefined;
    dateCreated?: string | undefined;
    dateModified?: string | undefined;
    createdBy?: number | undefined;
    updatedBy?: number | undefined;
    templateId?: number | undefined;
    timeDimension?: number | undefined;
    formulaeField?: string | undefined;
    value?: number | undefined;

    constructor(data?: IMetricDomainModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayLabel = _data["displayLabel"];
            this.typeId = _data["typeId"];
            this.groupId = _data["groupId"];
            this.metrictypeId = _data["metrictypeId"];
            this.typeName = _data["typeName"];
            this.validationId = _data["validationId"];
            this.validationName = _data["validationName"];
            this.lookupTable = _data["lookupTable"];
            this.lookupTableColumn = _data["lookupTableColumn"];
            this.metricsQuestion = _data["metricsQuestion"];
            this.esgrcType = _data["esgrcType"];
            this.esgrcName = _data["esgrcName"];
            this.uom = _data["uom"];
            this.uomName = _data["uomName"];
            this.category = _data["category"];
            this.categoryName = _data["categoryName"];
            this.standard = _data["standard"];
            this.standardName = _data["standardName"];
            this.departmentid = _data["departmentid"];
            this.departmentName = _data["departmentName"];
            this.target = _data["target"];
            this.standardYear = _data["standardYear"];
            this.serviceid = _data["serviceid"];
            this.parentid = _data["parentid"];
            this.regulationtypeid = _data["regulationtypeid"];
            this.isKeyIndicator = _data["isKeyIndicator"];
            this.serviceName = _data["serviceName"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.templateId = _data["templateId"];
            this.timeDimension = _data["timeDimension"];
            this.formulaeField = _data["formulaeField"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MetricDomainModel {
        data = typeof data === 'object' ? data : {};
        let result = new MetricDomainModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayLabel"] = this.displayLabel;
        data["typeId"] = this.typeId;
        data["groupId"] = this.groupId;
        data["metrictypeId"] = this.metrictypeId;
        data["typeName"] = this.typeName;
        data["validationId"] = this.validationId;
        data["validationName"] = this.validationName;
        data["lookupTable"] = this.lookupTable;
        data["lookupTableColumn"] = this.lookupTableColumn;
        data["metricsQuestion"] = this.metricsQuestion;
        data["esgrcType"] = this.esgrcType;
        data["esgrcName"] = this.esgrcName;
        data["uom"] = this.uom;
        data["uomName"] = this.uomName;
        data["category"] = this.category;
        data["categoryName"] = this.categoryName;
        data["standard"] = this.standard;
        data["standardName"] = this.standardName;
        data["departmentid"] = this.departmentid;
        data["departmentName"] = this.departmentName;
        data["target"] = this.target;
        data["standardYear"] = this.standardYear;
        data["serviceid"] = this.serviceid;
        data["parentid"] = this.parentid;
        data["regulationtypeid"] = this.regulationtypeid;
        data["isKeyIndicator"] = this.isKeyIndicator;
        data["serviceName"] = this.serviceName;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["templateId"] = this.templateId;
        data["timeDimension"] = this.timeDimension;
        data["formulaeField"] = this.formulaeField;
        data["value"] = this.value;
        return data;
    }
}

export interface IMetricDomainModel {
    id?: number | undefined;
    name?: string | undefined;
    displayLabel?: string | undefined;
    typeId?: number;
    groupId?: number;
    metrictypeId?: number;
    typeName?: string | undefined;
    validationId?: string | undefined;
    validationName?: string | undefined;
    lookupTable?: string | undefined;
    lookupTableColumn?: string | undefined;
    metricsQuestion?: string | undefined;
    esgrcType?: number;
    esgrcName?: string | undefined;
    uom?: number;
    uomName?: string | undefined;
    category?: number;
    categoryName?: string | undefined;
    standard?: number;
    standardName?: string | undefined;
    departmentid?: number;
    departmentName?: string | undefined;
    target?: string | undefined;
    standardYear?: string | undefined;
    serviceid?: number;
    parentid?: number | undefined;
    regulationtypeid?: number;
    isKeyIndicator?: boolean;
    serviceName?: string | undefined;
    dateCreated?: string | undefined;
    dateModified?: string | undefined;
    createdBy?: number | undefined;
    updatedBy?: number | undefined;
    templateId?: number | undefined;
    timeDimension?: number | undefined;
    formulaeField?: string | undefined;
    value?: number | undefined;
}

export class MetricDomainModelListApiResponse implements IMetricDomainModelListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricDomainModel[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricDomainModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MetricDomainModel.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricDomainModelListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricDomainModelListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricDomainModelListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricDomainModel[] | undefined;
    hasError?: boolean;
}

export class MetricGroup implements IMetricGroup {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    code?: number;
    label?: string | undefined;
    name?: string | undefined;
    complianceId?: number | undefined;
    industry?: number | undefined;
    parentId?: number | undefined;
    isHierarchy?: boolean | undefined;

    constructor(data?: IMetricGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.code = _data["code"];
            this.label = _data["label"];
            this.name = _data["name"];
            this.complianceId = _data["complianceId"];
            this.industry = _data["industry"];
            this.parentId = _data["parentId"];
            this.isHierarchy = _data["isHierarchy"];
        }
    }

    static fromJS(data: any): MetricGroup {
        data = typeof data === 'object' ? data : {};
        let result = new MetricGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["code"] = this.code;
        data["label"] = this.label;
        data["name"] = this.name;
        data["complianceId"] = this.complianceId;
        data["industry"] = this.industry;
        data["parentId"] = this.parentId;
        data["isHierarchy"] = this.isHierarchy;
        return data;
    }
}

export interface IMetricGroup {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    code?: number;
    label?: string | undefined;
    name?: string | undefined;
    complianceId?: number | undefined;
    industry?: number | undefined;
    parentId?: number | undefined;
    isHierarchy?: boolean | undefined;
}

export class MetricGroupListApiResponse implements IMetricGroupListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricGroup[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricGroupListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MetricGroup.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricGroupListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricGroupListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricGroupListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricGroup[] | undefined;
    hasError?: boolean;
}

export class MetricIEnumerableApiResponse implements IMetricIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Metric[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Metric.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Metric[] | undefined;
    hasError?: boolean;
}

export class MetricListApiResponse implements IMetricListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Metric[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Metric.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Metric[] | undefined;
    hasError?: boolean;
}

export class MetricQuestionAnswersDto implements IMetricQuestionAnswersDto {
    responseJson?: { [key: string]: any; } | undefined;
    metricGroupId?: number;
    templateId?: number | undefined;
    assessmentId?: number | undefined;
    id?: number;
    processId?: number;
    auditId?: number;

    constructor(data?: IMetricQuestionAnswersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["responseJson"]) {
                this.responseJson = {} as any;
                for (let key in _data["responseJson"]) {
                    if (_data["responseJson"].hasOwnProperty(key))
                        (<any>this.responseJson)![key] = _data["responseJson"][key];
                }
            }
            this.metricGroupId = _data["metricGroupId"];
            this.templateId = _data["templateId"];
            this.assessmentId = _data["assessmentId"];
            this.id = _data["id"];
            this.processId = _data["processId"];
            this.auditId = _data["auditId"];
        }
    }

    static fromJS(data: any): MetricQuestionAnswersDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetricQuestionAnswersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.responseJson) {
            data["responseJson"] = {};
            for (let key in this.responseJson) {
                if (this.responseJson.hasOwnProperty(key))
                    (<any>data["responseJson"])[key] = (<any>this.responseJson)[key];
            }
        }
        data["metricGroupId"] = this.metricGroupId;
        data["templateId"] = this.templateId;
        data["assessmentId"] = this.assessmentId;
        data["id"] = this.id;
        data["processId"] = this.processId;
        data["auditId"] = this.auditId;
        return data;
    }
}

export interface IMetricQuestionAnswersDto {
    responseJson?: { [key: string]: any; } | undefined;
    metricGroupId?: number;
    templateId?: number | undefined;
    assessmentId?: number | undefined;
    id?: number;
    processId?: number;
    auditId?: number;
}

export class MetricQuestionAnswersDtoIEnumerableApiResponse implements IMetricQuestionAnswersDtoIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricQuestionAnswersDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricQuestionAnswersDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MetricQuestionAnswersDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricQuestionAnswersDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricQuestionAnswersDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricQuestionAnswersDtoIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricQuestionAnswersDto[] | undefined;
    hasError?: boolean;
}

export class MetricStandard implements IMetricStandard {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    yearId?: number | undefined;
    standardJson?: string | undefined;
    uploadedFileid?: number;

    constructor(data?: IMetricStandard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.yearId = _data["yearId"];
            this.standardJson = _data["standardJson"];
            this.uploadedFileid = _data["uploadedFileid"];
        }
    }

    static fromJS(data: any): MetricStandard {
        data = typeof data === 'object' ? data : {};
        let result = new MetricStandard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["yearId"] = this.yearId;
        data["standardJson"] = this.standardJson;
        data["uploadedFileid"] = this.uploadedFileid;
        return data;
    }
}

export interface IMetricStandard {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    yearId?: number | undefined;
    standardJson?: string | undefined;
    uploadedFileid?: number;
}

export class MetricStandardDto implements IMetricStandardDto {
    id?: number;
    yearId?: number;
    yearName?: string | undefined;
    standardJson?: { [key: string]: any; } | undefined;
    uploadedFileid?: number;

    constructor(data?: IMetricStandardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.yearId = _data["yearId"];
            this.yearName = _data["yearName"];
            if (_data["standardJson"]) {
                this.standardJson = {} as any;
                for (let key in _data["standardJson"]) {
                    if (_data["standardJson"].hasOwnProperty(key))
                        (<any>this.standardJson)![key] = _data["standardJson"][key];
                }
            }
            this.uploadedFileid = _data["uploadedFileid"];
        }
    }

    static fromJS(data: any): MetricStandardDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetricStandardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["yearId"] = this.yearId;
        data["yearName"] = this.yearName;
        if (this.standardJson) {
            data["standardJson"] = {};
            for (let key in this.standardJson) {
                if (this.standardJson.hasOwnProperty(key))
                    (<any>data["standardJson"])[key] = (<any>this.standardJson)[key];
            }
        }
        data["uploadedFileid"] = this.uploadedFileid;
        return data;
    }
}

export interface IMetricStandardDto {
    id?: number;
    yearId?: number;
    yearName?: string | undefined;
    standardJson?: { [key: string]: any; } | undefined;
    uploadedFileid?: number;
}

export class MetricStandardDtoListApiResponse implements IMetricStandardDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricStandardDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricStandardDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MetricStandardDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricStandardDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricStandardDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricStandardDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricStandardDto[] | undefined;
    hasError?: boolean;
}

export class MetricStandardListApiResponse implements IMetricStandardListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricStandard[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricStandardListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MetricStandard.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricStandardListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricStandardListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricStandardListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricStandard[] | undefined;
    hasError?: boolean;
}

export class MetricType implements IMetricType {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    code?: number | undefined;
    icon?: string | undefined;

    constructor(data?: IMetricType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.code = _data["code"];
            this.icon = _data["icon"];
        }
    }

    static fromJS(data: any): MetricType {
        data = typeof data === 'object' ? data : {};
        let result = new MetricType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["description"] = this.description;
        data["code"] = this.code;
        data["icon"] = this.icon;
        return data;
    }
}

export interface IMetricType {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    code?: number | undefined;
    icon?: string | undefined;
}

export class MetricTypeIEnumerableApiResponse implements IMetricTypeIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricType[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricTypeIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MetricType.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricTypeIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricTypeIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricTypeIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricType[] | undefined;
    hasError?: boolean;
}

export class MetricsPrefix implements IMetricsPrefix {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IMetricsPrefix) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): MetricsPrefix {
        data = typeof data === 'object' ? data : {};
        let result = new MetricsPrefix();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IMetricsPrefix {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class MetricsPrefixIEnumerableApiResponse implements IMetricsPrefixIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricsPrefix[] | undefined;
    hasError?: boolean;

    constructor(data?: IMetricsPrefixIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MetricsPrefix.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MetricsPrefixIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MetricsPrefixIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMetricsPrefixIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MetricsPrefix[] | undefined;
    hasError?: boolean;
}

export class MgmultiselectionDto implements IMgmultiselectionDto {
    id?: number | undefined;
    metricId?: number;
    metricgroupId?: number;
    metricsquestion?: string | undefined;
    typeName?: string | undefined;

    constructor(data?: IMgmultiselectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.metricId = _data["metricId"];
            this.metricgroupId = _data["metricgroupId"];
            this.metricsquestion = _data["metricsquestion"];
            this.typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): MgmultiselectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MgmultiselectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["metricId"] = this.metricId;
        data["metricgroupId"] = this.metricgroupId;
        data["metricsquestion"] = this.metricsquestion;
        data["typeName"] = this.typeName;
        return data;
    }
}

export interface IMgmultiselectionDto {
    id?: number | undefined;
    metricId?: number;
    metricgroupId?: number;
    metricsquestion?: string | undefined;
    typeName?: string | undefined;
}

export class MgmultiselectionDtoListApiResponse implements IMgmultiselectionDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MgmultiselectionDto[] | undefined;
    hasError?: boolean;

    constructor(data?: IMgmultiselectionDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MgmultiselectionDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MgmultiselectionDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MgmultiselectionDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMgmultiselectionDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: MgmultiselectionDto[] | undefined;
    hasError?: boolean;
}

export class Months implements IMonths {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IMonths) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Months {
        data = typeof data === 'object' ? data : {};
        let result = new Months();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IMonths {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class MonthsIEnumerableApiResponse implements IMonthsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Months[] | undefined;
    hasError?: boolean;

    constructor(data?: IMonthsIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Months.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): MonthsIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MonthsIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IMonthsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Months[] | undefined;
    hasError?: boolean;
}

export class NewCities implements INewCities {
    code?: number;
    country?: string | undefined;
    state?: string | undefined;
    district?: string | undefined;
    zone?: string | undefined;
    city?: string | undefined;

    constructor(data?: INewCities) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.district = _data["district"];
            this.zone = _data["zone"];
            this.city = _data["city"];
        }
    }

    static fromJS(data: any): NewCities {
        data = typeof data === 'object' ? data : {};
        let result = new NewCities();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["country"] = this.country;
        data["state"] = this.state;
        data["district"] = this.district;
        data["zone"] = this.zone;
        data["city"] = this.city;
        return data;
    }
}

export interface INewCities {
    code?: number;
    country?: string | undefined;
    state?: string | undefined;
    district?: string | undefined;
    zone?: string | undefined;
    city?: string | undefined;
}

export class NewCitiesListApiResponse implements INewCitiesListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: NewCities[] | undefined;
    hasError?: boolean;

    constructor(data?: INewCitiesListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(NewCities.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): NewCitiesListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NewCitiesListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface INewCitiesListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: NewCities[] | undefined;
    hasError?: boolean;
}

export class ObjectListApiResponse implements IObjectListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: any[] | undefined;
    hasError?: boolean;

    constructor(data?: IObjectListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ObjectListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IObjectListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: any[] | undefined;
    hasError?: boolean;
}

export class Organizations implements IOrganizations {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IOrganizations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Organizations {
        data = typeof data === 'object' ? data : {};
        let result = new Organizations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IOrganizations {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class OrganizationsIEnumerableApiResponse implements IOrganizationsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Organizations[] | undefined;
    hasError?: boolean;

    constructor(data?: IOrganizationsIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Organizations.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): OrganizationsIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationsIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IOrganizationsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Organizations[] | undefined;
    hasError?: boolean;
}

export class PdfReports implements IPdfReports {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    guid?: string | undefined;
    reportName?: string | undefined;
    pageNumber?: number | undefined;
    url?: string | undefined;
    type?: string | undefined;
    datasetName?: string | undefined;

    constructor(data?: IPdfReports) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.guid = _data["guid"];
            this.reportName = _data["reportName"];
            this.pageNumber = _data["pageNumber"];
            this.url = _data["url"];
            this.type = _data["type"];
            this.datasetName = _data["datasetName"];
        }
    }

    static fromJS(data: any): PdfReports {
        data = typeof data === 'object' ? data : {};
        let result = new PdfReports();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["guid"] = this.guid;
        data["reportName"] = this.reportName;
        data["pageNumber"] = this.pageNumber;
        data["url"] = this.url;
        data["type"] = this.type;
        data["datasetName"] = this.datasetName;
        return data;
    }
}

export interface IPdfReports {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    guid?: string | undefined;
    reportName?: string | undefined;
    pageNumber?: number | undefined;
    url?: string | undefined;
    type?: string | undefined;
    datasetName?: string | undefined;
}

export class PdfReportsListApiResponse implements IPdfReportsListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: PdfReports[] | undefined;
    hasError?: boolean;

    constructor(data?: IPdfReportsListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PdfReports.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): PdfReportsListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PdfReportsListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IPdfReportsListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: PdfReports[] | undefined;
    hasError?: boolean;
}

export class Period implements IPeriod {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    month?: string | undefined;
    fiscalYearId?: number;
    quatter?: number;
    yearName?: string | undefined;

    constructor(data?: IPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.month = _data["month"];
            this.fiscalYearId = _data["fiscalYearId"];
            this.quatter = _data["quatter"];
            this.yearName = _data["yearName"];
        }
    }

    static fromJS(data: any): Period {
        data = typeof data === 'object' ? data : {};
        let result = new Period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["month"] = this.month;
        data["fiscalYearId"] = this.fiscalYearId;
        data["quatter"] = this.quatter;
        data["yearName"] = this.yearName;
        return data;
    }
}

export interface IPeriod {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    month?: string | undefined;
    fiscalYearId?: number;
    quatter?: number;
    yearName?: string | undefined;
}

export class PeriodListApiResponse implements IPeriodListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Period[] | undefined;
    hasError?: boolean;

    constructor(data?: IPeriodListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Period.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): PeriodListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IPeriodListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Period[] | undefined;
    hasError?: boolean;
}

export class PlanagromRecortList implements IPlanagromRecortList {
    actionedbyL1?: string | undefined;
    l1ActionDate?: string | undefined;
    planoOrFamilyNameCreationStatusL1?: string | undefined;
    firstLevelComments?: string | undefined;
    secondLevelComments?: string | undefined;
    actionedbyL2?: string | undefined;
    planoOrFamilyNameCreationStatusL2?: string | undefined;
    l2ActionDate?: string | undefined;
    id?: number;
    recordId?: number;
    planoOrFamilyName?: string | undefined;
    requestType?: string | undefined;
    division?: string | undefined;
    description?: string | undefined;
    planoOrFamilyCreatedBy?: string | undefined;
    planoOrFamilyCreatedDate?: string | undefined;
    taskStepInstanceId?: number;
    planoOrFamilyCode?: string | undefined;
    planoOrFamilyCodeUpdatedDate?: string | undefined;
    planoOrFamilyCodeStatus?: string | undefined;
    l1RejectDescription?: string | undefined;
    l2RejectDescription?: string | undefined;
    datecreated?: string | undefined;

    constructor(data?: IPlanagromRecortList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionedbyL1 = _data["actionedbyL1"];
            this.l1ActionDate = _data["l1ActionDate"];
            this.planoOrFamilyNameCreationStatusL1 = _data["planoOrFamilyNameCreationStatusL1"];
            this.firstLevelComments = _data["firstLevelComments"];
            this.secondLevelComments = _data["secondLevelComments"];
            this.actionedbyL2 = _data["actionedbyL2"];
            this.planoOrFamilyNameCreationStatusL2 = _data["planoOrFamilyNameCreationStatusL2"];
            this.l2ActionDate = _data["l2ActionDate"];
            this.id = _data["id"];
            this.recordId = _data["recordId"];
            this.planoOrFamilyName = _data["planoOrFamilyName"];
            this.requestType = _data["requestType"];
            this.division = _data["division"];
            this.description = _data["description"];
            this.planoOrFamilyCreatedBy = _data["planoOrFamilyCreatedBy"];
            this.planoOrFamilyCreatedDate = _data["planoOrFamilyCreatedDate"];
            this.taskStepInstanceId = _data["taskStepInstanceId"];
            this.planoOrFamilyCode = _data["planoOrFamilyCode"];
            this.planoOrFamilyCodeUpdatedDate = _data["planoOrFamilyCodeUpdatedDate"];
            this.planoOrFamilyCodeStatus = _data["planoOrFamilyCodeStatus"];
            this.l1RejectDescription = _data["l1RejectDescription"];
            this.l2RejectDescription = _data["l2RejectDescription"];
            this.datecreated = _data["datecreated"];
        }
    }

    static fromJS(data: any): PlanagromRecortList {
        data = typeof data === 'object' ? data : {};
        let result = new PlanagromRecortList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionedbyL1"] = this.actionedbyL1;
        data["l1ActionDate"] = this.l1ActionDate;
        data["planoOrFamilyNameCreationStatusL1"] = this.planoOrFamilyNameCreationStatusL1;
        data["firstLevelComments"] = this.firstLevelComments;
        data["secondLevelComments"] = this.secondLevelComments;
        data["actionedbyL2"] = this.actionedbyL2;
        data["planoOrFamilyNameCreationStatusL2"] = this.planoOrFamilyNameCreationStatusL2;
        data["l2ActionDate"] = this.l2ActionDate;
        data["id"] = this.id;
        data["recordId"] = this.recordId;
        data["planoOrFamilyName"] = this.planoOrFamilyName;
        data["requestType"] = this.requestType;
        data["division"] = this.division;
        data["description"] = this.description;
        data["planoOrFamilyCreatedBy"] = this.planoOrFamilyCreatedBy;
        data["planoOrFamilyCreatedDate"] = this.planoOrFamilyCreatedDate;
        data["taskStepInstanceId"] = this.taskStepInstanceId;
        data["planoOrFamilyCode"] = this.planoOrFamilyCode;
        data["planoOrFamilyCodeUpdatedDate"] = this.planoOrFamilyCodeUpdatedDate;
        data["planoOrFamilyCodeStatus"] = this.planoOrFamilyCodeStatus;
        data["l1RejectDescription"] = this.l1RejectDescription;
        data["l2RejectDescription"] = this.l2RejectDescription;
        data["datecreated"] = this.datecreated;
        return data;
    }
}

export interface IPlanagromRecortList {
    actionedbyL1?: string | undefined;
    l1ActionDate?: string | undefined;
    planoOrFamilyNameCreationStatusL1?: string | undefined;
    firstLevelComments?: string | undefined;
    secondLevelComments?: string | undefined;
    actionedbyL2?: string | undefined;
    planoOrFamilyNameCreationStatusL2?: string | undefined;
    l2ActionDate?: string | undefined;
    id?: number;
    recordId?: number;
    planoOrFamilyName?: string | undefined;
    requestType?: string | undefined;
    division?: string | undefined;
    description?: string | undefined;
    planoOrFamilyCreatedBy?: string | undefined;
    planoOrFamilyCreatedDate?: string | undefined;
    taskStepInstanceId?: number;
    planoOrFamilyCode?: string | undefined;
    planoOrFamilyCodeUpdatedDate?: string | undefined;
    planoOrFamilyCodeStatus?: string | undefined;
    l1RejectDescription?: string | undefined;
    l2RejectDescription?: string | undefined;
    datecreated?: string | undefined;
}

export class PlanagromRecortListListApiResponse implements IPlanagromRecortListListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: PlanagromRecortList[] | undefined;
    hasError?: boolean;

    constructor(data?: IPlanagromRecortListListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PlanagromRecortList.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): PlanagromRecortListListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PlanagromRecortListListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IPlanagromRecortListListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: PlanagromRecortList[] | undefined;
    hasError?: boolean;
}

export class PrefixMetricsModel implements IPrefixMetricsModel {
    metric?: string | undefined;
    dataType?: string | undefined;

    constructor(data?: IPrefixMetricsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metric = _data["metric"];
            this.dataType = _data["dataType"];
        }
    }

    static fromJS(data: any): PrefixMetricsModel {
        data = typeof data === 'object' ? data : {};
        let result = new PrefixMetricsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metric"] = this.metric;
        data["dataType"] = this.dataType;
        return data;
    }
}

export interface IPrefixMetricsModel {
    metric?: string | undefined;
    dataType?: string | undefined;
}

export class PrefixMetricsModelListApiResponse implements IPrefixMetricsModelListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: PrefixMetricsModel[] | undefined;
    hasError?: boolean;

    constructor(data?: IPrefixMetricsModelListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PrefixMetricsModel.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): PrefixMetricsModelListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PrefixMetricsModelListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IPrefixMetricsModelListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: PrefixMetricsModel[] | undefined;
    hasError?: boolean;
}

export class Process implements IProcess {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
    complianceId?: number;

    constructor(data?: IProcess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.complianceId = _data["complianceId"];
        }
    }

    static fromJS(data: any): Process {
        data = typeof data === 'object' ? data : {};
        let result = new Process();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        data["complianceId"] = this.complianceId;
        return data;
    }
}

export interface IProcess {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
    complianceId?: number;
}

export class ProcessApiResponse implements IProcessApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Process;
    hasError?: boolean;

    constructor(data?: IProcessApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? Process.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ProcessApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IProcessApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Process;
    hasError?: boolean;
}

export class ProcessDomainModal implements IProcessDomainModal {
    id?: number;
    complianceName?: string | undefined;
    complianceId?: number;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IProcessDomainModal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.complianceName = _data["complianceName"];
            this.complianceId = _data["complianceId"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ProcessDomainModal {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDomainModal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["complianceName"] = this.complianceName;
        data["complianceId"] = this.complianceId;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IProcessDomainModal {
    id?: number;
    complianceName?: string | undefined;
    complianceId?: number;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class ProcessDomainModalListApiResponse implements IProcessDomainModalListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ProcessDomainModal[] | undefined;
    hasError?: boolean;

    constructor(data?: IProcessDomainModalListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ProcessDomainModal.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ProcessDomainModalListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDomainModalListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IProcessDomainModalListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ProcessDomainModal[] | undefined;
    hasError?: boolean;
}

export class Quatter implements IQuatter {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IQuatter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Quatter {
        data = typeof data === 'object' ? data : {};
        let result = new Quatter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IQuatter {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class QuatterIEnumerableApiResponse implements IQuatterIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Quatter[] | undefined;
    hasError?: boolean;

    constructor(data?: IQuatterIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Quatter.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): QuatterIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuatterIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IQuatterIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Quatter[] | undefined;
    hasError?: boolean;
}

export class Queries implements IQueries {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    processname?: number | undefined;
    assignedto?: number | undefined;
    querydescription?: string | undefined;
    response?: string | undefined;
    status?: number | undefined;
    isChangeNeeded?: boolean | undefined;
    auditId?: number | undefined;
    templatestageId?: number | undefined;
    processstageId?: number | undefined;

    constructor(data?: IQueries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.processname = _data["processname"];
            this.assignedto = _data["assignedto"];
            this.querydescription = _data["querydescription"];
            this.response = _data["response"];
            this.status = _data["status"];
            this.isChangeNeeded = _data["isChangeNeeded"];
            this.auditId = _data["auditId"];
            this.templatestageId = _data["templatestageId"];
            this.processstageId = _data["processstageId"];
        }
    }

    static fromJS(data: any): Queries {
        data = typeof data === 'object' ? data : {};
        let result = new Queries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["processname"] = this.processname;
        data["assignedto"] = this.assignedto;
        data["querydescription"] = this.querydescription;
        data["response"] = this.response;
        data["status"] = this.status;
        data["isChangeNeeded"] = this.isChangeNeeded;
        data["auditId"] = this.auditId;
        data["templatestageId"] = this.templatestageId;
        data["processstageId"] = this.processstageId;
        return data;
    }
}

export interface IQueries {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    processname?: number | undefined;
    assignedto?: number | undefined;
    querydescription?: string | undefined;
    response?: string | undefined;
    status?: number | undefined;
    isChangeNeeded?: boolean | undefined;
    auditId?: number | undefined;
    templatestageId?: number | undefined;
    processstageId?: number | undefined;
}

export class RejectionReason implements IRejectionReason {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IRejectionReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): RejectionReason {
        data = typeof data === 'object' ? data : {};
        let result = new RejectionReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IRejectionReason {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
}

export class RejectionReasonIEnumerableApiResponse implements IRejectionReasonIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: RejectionReason[] | undefined;
    hasError?: boolean;

    constructor(data?: IRejectionReasonIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(RejectionReason.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): RejectionReasonIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RejectionReasonIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IRejectionReasonIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: RejectionReason[] | undefined;
    hasError?: boolean;
}

export class ReportCountsModel implements IReportCountsModel {
    groupedItem?: string | undefined;
    reportCount?: number;

    constructor(data?: IReportCountsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupedItem = _data["groupedItem"];
            this.reportCount = _data["reportCount"];
        }
    }

    static fromJS(data: any): ReportCountsModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReportCountsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupedItem"] = this.groupedItem;
        data["reportCount"] = this.reportCount;
        return data;
    }
}

export interface IReportCountsModel {
    groupedItem?: string | undefined;
    reportCount?: number;
}

export class ReportCountsModelIEnumerableApiResponse implements IReportCountsModelIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ReportCountsModel[] | undefined;
    hasError?: boolean;

    constructor(data?: IReportCountsModelIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ReportCountsModel.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ReportCountsModelIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReportCountsModelIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IReportCountsModelIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ReportCountsModel[] | undefined;
    hasError?: boolean;
}

export class Role implements IRole {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IRole {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class RoleIEnumerableApiResponse implements IRoleIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Role[] | undefined;
    hasError?: boolean;

    constructor(data?: IRoleIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Role.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): RoleIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IRoleIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Role[] | undefined;
    hasError?: boolean;
}

export class Season implements ISeason {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: ISeason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Season {
        data = typeof data === 'object' ? data : {};
        let result = new Season();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ISeason {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: string | undefined;
}

export class SeasonIEnumerableApiResponse implements ISeasonIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Season[] | undefined;
    hasError?: boolean;

    constructor(data?: ISeasonIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Season.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): SeasonIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ISeasonIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Season[] | undefined;
    hasError?: boolean;
}

export class Service implements IService {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Service {
        data = typeof data === 'object' ? data : {};
        let result = new Service();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IService {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class ServiceIEnumerableApiResponse implements IServiceIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Service[] | undefined;
    hasError?: boolean;

    constructor(data?: IServiceIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Service.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ServiceIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IServiceIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Service[] | undefined;
    hasError?: boolean;
}

export class StageAction implements IStageAction {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IStageAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): StageAction {
        data = typeof data === 'object' ? data : {};
        let result = new StageAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IStageAction {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class StageActionIEnumerableApiResponse implements IStageActionIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: StageAction[] | undefined;
    hasError?: boolean;

    constructor(data?: IStageActionIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(StageAction.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): StageActionIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StageActionIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IStageActionIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: StageAction[] | undefined;
    hasError?: boolean;
}

export class Standards implements IStandards {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IStandards) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Standards {
        data = typeof data === 'object' ? data : {};
        let result = new Standards();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IStandards {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class StandardsIEnumerableApiResponse implements IStandardsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Standards[] | undefined;
    hasError?: boolean;

    constructor(data?: IStandardsIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Standards.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): StandardsIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StandardsIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IStandardsIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Standards[] | undefined;
    hasError?: boolean;
}

export class StringApiResponse implements IStringApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: string | undefined;
    hasError?: boolean;

    constructor(data?: IStringApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"];
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): StringApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IStringApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: string | undefined;
    hasError?: boolean;
}

export class StringIEnumerableApiResponse implements IStringIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: string[] | undefined;
    hasError?: boolean;

    constructor(data?: IStringIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): StringIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IStringIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: string[] | undefined;
    hasError?: boolean;
}

export class StringListApiResponse implements IStringListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: string[] | undefined;
    hasError?: boolean;

    constructor(data?: IStringListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): StringListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IStringListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: string[] | undefined;
    hasError?: boolean;
}

export class StringObjectDictionaryListApiResponse implements IStringObjectDictionaryListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: { [key: string]: any; }[] | undefined;
    hasError?: boolean;

    constructor(data?: IStringObjectDictionaryListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): StringObjectDictionaryListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringObjectDictionaryListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IStringObjectDictionaryListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: { [key: string]: any; }[] | undefined;
    hasError?: boolean;
}

export class TableMetaDataColumn implements ITableMetaDataColumn {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: ITableMetaDataColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): TableMetaDataColumn {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetaDataColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ITableMetaDataColumn {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class TableMetaDataColumnIEnumerableApiResponse implements ITableMetaDataColumnIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TableMetaDataColumn[] | undefined;
    hasError?: boolean;

    constructor(data?: ITableMetaDataColumnIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TableMetaDataColumn.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TableMetaDataColumnIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetaDataColumnIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITableMetaDataColumnIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TableMetaDataColumn[] | undefined;
    hasError?: boolean;
}

export class TableMetadata implements ITableMetadata {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: ITableMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): TableMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ITableMetadata {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class TableMetadataIEnumerableApiResponse implements ITableMetadataIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TableMetadata[] | undefined;
    hasError?: boolean;

    constructor(data?: ITableMetadataIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TableMetadata.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TableMetadataIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetadataIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITableMetadataIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TableMetadata[] | undefined;
    hasError?: boolean;
}

export class TableMetadataListApiResponse implements ITableMetadataListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TableMetadata[] | undefined;
    hasError?: boolean;

    constructor(data?: ITableMetadataListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TableMetadata.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TableMetadataListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetadataListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITableMetadataListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TableMetadata[] | undefined;
    hasError?: boolean;
}

export class TaskAction implements ITaskAction {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    plannedStartDate?: string | undefined;
    plannedEndDate?: string | undefined;
    actualStartDate?: string | undefined;
    actualEndDate?: string | undefined;
    metricId?: number | undefined;
    status?: number | undefined;
    objectId?: number | undefined;
    objectName?: string | undefined;

    constructor(data?: ITaskAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.plannedStartDate = _data["plannedStartDate"];
            this.plannedEndDate = _data["plannedEndDate"];
            this.actualStartDate = _data["actualStartDate"];
            this.actualEndDate = _data["actualEndDate"];
            this.metricId = _data["metricId"];
            this.status = _data["status"];
            this.objectId = _data["objectId"];
            this.objectName = _data["objectName"];
        }
    }

    static fromJS(data: any): TaskAction {
        data = typeof data === 'object' ? data : {};
        let result = new TaskAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["plannedStartDate"] = this.plannedStartDate;
        data["plannedEndDate"] = this.plannedEndDate;
        data["actualStartDate"] = this.actualStartDate;
        data["actualEndDate"] = this.actualEndDate;
        data["metricId"] = this.metricId;
        data["status"] = this.status;
        data["objectId"] = this.objectId;
        data["objectName"] = this.objectName;
        return data;
    }
}

export interface ITaskAction {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    plannedStartDate?: string | undefined;
    plannedEndDate?: string | undefined;
    actualStartDate?: string | undefined;
    actualEndDate?: string | undefined;
    metricId?: number | undefined;
    status?: number | undefined;
    objectId?: number | undefined;
    objectName?: string | undefined;
}

export class TaskActionDto implements ITaskActionDto {
    description?: string | undefined;
    plannedStartDate?: string | undefined;
    plannedEndDate?: string | undefined;
    actualStartDate?: string | undefined;
    actualEndDate?: string | undefined;
    status?: number | undefined;
    objectId?: number | undefined;
    objectName?: string | undefined;
    regulationName?: string | undefined;
    metricName?: string | undefined;
    id?: string | undefined;

    constructor(data?: ITaskActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.plannedStartDate = _data["plannedStartDate"];
            this.plannedEndDate = _data["plannedEndDate"];
            this.actualStartDate = _data["actualStartDate"];
            this.actualEndDate = _data["actualEndDate"];
            this.status = _data["status"];
            this.objectId = _data["objectId"];
            this.objectName = _data["objectName"];
            this.regulationName = _data["regulationName"];
            this.metricName = _data["metricName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaskActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["plannedStartDate"] = this.plannedStartDate;
        data["plannedEndDate"] = this.plannedEndDate;
        data["actualStartDate"] = this.actualStartDate;
        data["actualEndDate"] = this.actualEndDate;
        data["status"] = this.status;
        data["objectId"] = this.objectId;
        data["objectName"] = this.objectName;
        data["regulationName"] = this.regulationName;
        data["metricName"] = this.metricName;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaskActionDto {
    description?: string | undefined;
    plannedStartDate?: string | undefined;
    plannedEndDate?: string | undefined;
    actualStartDate?: string | undefined;
    actualEndDate?: string | undefined;
    status?: number | undefined;
    objectId?: number | undefined;
    objectName?: string | undefined;
    regulationName?: string | undefined;
    metricName?: string | undefined;
    id?: string | undefined;
}

export class TaskActionDtoIEnumerableApiResponse implements ITaskActionDtoIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TaskActionDto[] | undefined;
    hasError?: boolean;

    constructor(data?: ITaskActionDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TaskActionDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TaskActionDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskActionDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITaskActionDtoIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TaskActionDto[] | undefined;
    hasError?: boolean;
}

export class TaskStepInstance implements ITaskStepInstance {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    tableName?: string | undefined;
    sequence?: number;
    isParallel?: boolean;
    nextStepId?: number | undefined;
    isFinalStep?: boolean;
    isNextStep?: boolean;
    ownerId?: number;
    ownerRoleId?: number | undefined;
    isAll?: boolean;
    workflowDesignId?: number;
    rejectedStageId?: number | undefined;
    action?: string | undefined;
    userActionJson?: string | undefined;
    activity?: number;
    typeId?: number;
    actionTemplateId?: number | undefined;
    rejectTemplateId?: number | undefined;
    taskStepId?: number;
    workflowRunId?: number;
    taskStepInstanceStatusId?: number;
    userComments?: string | undefined;
    title?: string | undefined;

    constructor(data?: ITaskStepInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.tableName = _data["tableName"];
            this.sequence = _data["sequence"];
            this.isParallel = _data["isParallel"];
            this.nextStepId = _data["nextStepId"];
            this.isFinalStep = _data["isFinalStep"];
            this.isNextStep = _data["isNextStep"];
            this.ownerId = _data["ownerId"];
            this.ownerRoleId = _data["ownerRoleId"];
            this.isAll = _data["isAll"];
            this.workflowDesignId = _data["workflowDesignId"];
            this.rejectedStageId = _data["rejectedStageId"];
            this.action = _data["action"];
            this.userActionJson = _data["userActionJson"];
            this.activity = _data["activity"];
            this.typeId = _data["typeId"];
            this.actionTemplateId = _data["actionTemplateId"];
            this.rejectTemplateId = _data["rejectTemplateId"];
            this.taskStepId = _data["taskStepId"];
            this.workflowRunId = _data["workflowRunId"];
            this.taskStepInstanceStatusId = _data["taskStepInstanceStatusId"];
            this.userComments = _data["userComments"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): TaskStepInstance {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStepInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["tableName"] = this.tableName;
        data["sequence"] = this.sequence;
        data["isParallel"] = this.isParallel;
        data["nextStepId"] = this.nextStepId;
        data["isFinalStep"] = this.isFinalStep;
        data["isNextStep"] = this.isNextStep;
        data["ownerId"] = this.ownerId;
        data["ownerRoleId"] = this.ownerRoleId;
        data["isAll"] = this.isAll;
        data["workflowDesignId"] = this.workflowDesignId;
        data["rejectedStageId"] = this.rejectedStageId;
        data["action"] = this.action;
        data["userActionJson"] = this.userActionJson;
        data["activity"] = this.activity;
        data["typeId"] = this.typeId;
        data["actionTemplateId"] = this.actionTemplateId;
        data["rejectTemplateId"] = this.rejectTemplateId;
        data["taskStepId"] = this.taskStepId;
        data["workflowRunId"] = this.workflowRunId;
        data["taskStepInstanceStatusId"] = this.taskStepInstanceStatusId;
        data["userComments"] = this.userComments;
        data["title"] = this.title;
        return data;
    }
}

export interface ITaskStepInstance {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    tableName?: string | undefined;
    sequence?: number;
    isParallel?: boolean;
    nextStepId?: number | undefined;
    isFinalStep?: boolean;
    isNextStep?: boolean;
    ownerId?: number;
    ownerRoleId?: number | undefined;
    isAll?: boolean;
    workflowDesignId?: number;
    rejectedStageId?: number | undefined;
    action?: string | undefined;
    userActionJson?: string | undefined;
    activity?: number;
    typeId?: number;
    actionTemplateId?: number | undefined;
    rejectTemplateId?: number | undefined;
    taskStepId?: number;
    workflowRunId?: number;
    taskStepInstanceStatusId?: number;
    userComments?: string | undefined;
    title?: string | undefined;
}

export class TaskStepInstanceListApiResponse implements ITaskStepInstanceListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TaskStepInstance[] | undefined;
    hasError?: boolean;

    constructor(data?: ITaskStepInstanceListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TaskStepInstance.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TaskStepInstanceListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStepInstanceListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITaskStepInstanceListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TaskStepInstance[] | undefined;
    hasError?: boolean;
}

export class TasklevelSequence implements ITasklevelSequence {
    taskStepId?: number | undefined;
    taskStepInstanceId?: number;
    taskNextStepId?: number | undefined;
    recordId?: number | undefined;
    userAction?: string | undefined;
    successMessge?: string | undefined;
    userComments?: string | undefined;
    rejectDescription?: string | undefined;

    constructor(data?: ITasklevelSequence) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskStepId = _data["taskStepId"];
            this.taskStepInstanceId = _data["taskStepInstanceId"];
            this.taskNextStepId = _data["taskNextStepId"];
            this.recordId = _data["recordId"];
            this.userAction = _data["userAction"];
            this.successMessge = _data["successMessge"];
            this.userComments = _data["userComments"];
            this.rejectDescription = _data["rejectDescription"];
        }
    }

    static fromJS(data: any): TasklevelSequence {
        data = typeof data === 'object' ? data : {};
        let result = new TasklevelSequence();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskStepId"] = this.taskStepId;
        data["taskStepInstanceId"] = this.taskStepInstanceId;
        data["taskNextStepId"] = this.taskNextStepId;
        data["recordId"] = this.recordId;
        data["userAction"] = this.userAction;
        data["successMessge"] = this.successMessge;
        data["userComments"] = this.userComments;
        data["rejectDescription"] = this.rejectDescription;
        return data;
    }
}

export interface ITasklevelSequence {
    taskStepId?: number | undefined;
    taskStepInstanceId?: number;
    taskNextStepId?: number | undefined;
    recordId?: number | undefined;
    userAction?: string | undefined;
    successMessge?: string | undefined;
    userComments?: string | undefined;
    rejectDescription?: string | undefined;
}

export class TasklevelSequenceListApiResponse implements ITasklevelSequenceListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TasklevelSequence[] | undefined;
    hasError?: boolean;

    constructor(data?: ITasklevelSequenceListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TasklevelSequence.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TasklevelSequenceListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TasklevelSequenceListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITasklevelSequenceListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TasklevelSequence[] | undefined;
    hasError?: boolean;
}

export class Template implements ITemplate {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    roleIds?: number[] | undefined;
    description?: string | undefined;
    metricGroupId?: number | undefined;
    appUserId?: number | undefined;
    isSFTP?: boolean | undefined;

    constructor(data?: ITemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.description = _data["description"];
            this.metricGroupId = _data["metricGroupId"];
            this.appUserId = _data["appUserId"];
            this.isSFTP = _data["isSFTP"];
        }
    }

    static fromJS(data: any): Template {
        data = typeof data === 'object' ? data : {};
        let result = new Template();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["description"] = this.description;
        data["metricGroupId"] = this.metricGroupId;
        data["appUserId"] = this.appUserId;
        data["isSFTP"] = this.isSFTP;
        return data;
    }
}

export interface ITemplate {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    roleIds?: number[] | undefined;
    description?: string | undefined;
    metricGroupId?: number | undefined;
    appUserId?: number | undefined;
    isSFTP?: boolean | undefined;
}

export class TemplateGroupDto implements ITemplateGroupDto {
    metricId?: number | undefined;
    name?: string | undefined;
    id?: number | undefined;
    templateId?: number | undefined;
    processId?: number | undefined;
    templateName?: string | undefined;
    metricGroupId?: number | undefined;
    metricGroupName?: string | undefined;
    dataType?: ValidationListEnum;
    dataTypeName?: string | undefined;
    title?: string | undefined;
    formValue?: string | undefined;
    assessmentId?: string | undefined;
    assessmentName?: string | undefined;

    constructor(data?: ITemplateGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metricId = _data["metricId"];
            this.name = _data["name"];
            this.id = _data["id"];
            this.templateId = _data["templateId"];
            this.processId = _data["processId"];
            this.templateName = _data["templateName"];
            this.metricGroupId = _data["metricGroupId"];
            this.metricGroupName = _data["metricGroupName"];
            this.dataType = _data["dataType"];
            this.dataTypeName = _data["dataTypeName"];
            this.title = _data["title"];
            this.formValue = _data["formValue"];
            this.assessmentId = _data["assessmentId"];
            this.assessmentName = _data["assessmentName"];
        }
    }

    static fromJS(data: any): TemplateGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metricId"] = this.metricId;
        data["name"] = this.name;
        data["id"] = this.id;
        data["templateId"] = this.templateId;
        data["processId"] = this.processId;
        data["templateName"] = this.templateName;
        data["metricGroupId"] = this.metricGroupId;
        data["metricGroupName"] = this.metricGroupName;
        data["dataType"] = this.dataType;
        data["dataTypeName"] = this.dataTypeName;
        data["title"] = this.title;
        data["formValue"] = this.formValue;
        data["assessmentId"] = this.assessmentId;
        data["assessmentName"] = this.assessmentName;
        return data;
    }
}

export interface ITemplateGroupDto {
    metricId?: number | undefined;
    name?: string | undefined;
    id?: number | undefined;
    templateId?: number | undefined;
    processId?: number | undefined;
    templateName?: string | undefined;
    metricGroupId?: number | undefined;
    metricGroupName?: string | undefined;
    dataType?: ValidationListEnum;
    dataTypeName?: string | undefined;
    title?: string | undefined;
    formValue?: string | undefined;
    assessmentId?: string | undefined;
    assessmentName?: string | undefined;
}

export class TemplateGroupDtoListApiResponse implements ITemplateGroupDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateGroupDto[] | undefined;
    hasError?: boolean;

    constructor(data?: ITemplateGroupDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TemplateGroupDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TemplateGroupDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateGroupDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITemplateGroupDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateGroupDto[] | undefined;
    hasError?: boolean;
}

export class TemplateIAsyncEnumerableApiResponse implements ITemplateIAsyncEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Template[] | undefined;
    hasError?: boolean;

    constructor(data?: ITemplateIAsyncEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Template.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TemplateIAsyncEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateIAsyncEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITemplateIAsyncEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Template[] | undefined;
    hasError?: boolean;
}

export class TemplateIEnumerableApiResponse implements ITemplateIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Template[] | undefined;
    hasError?: boolean;

    constructor(data?: ITemplateIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Template.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TemplateIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITemplateIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Template[] | undefined;
    hasError?: boolean;
}

export class TemplateMetrics implements ITemplateMetrics {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    templateId?: number;
    metricId?: number;

    constructor(data?: ITemplateMetrics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.templateId = _data["templateId"];
            this.metricId = _data["metricId"];
        }
    }

    static fromJS(data: any): TemplateMetrics {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateMetrics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["templateId"] = this.templateId;
        data["metricId"] = this.metricId;
        return data;
    }
}

export interface ITemplateMetrics {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    templateId?: number;
    metricId?: number;
}

export class TemplateSearchResult implements ITemplateSearchResult {
    totalNoOfRecords?: number;
    records?: Template[] | undefined;

    constructor(data?: ITemplateSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalNoOfRecords = _data["totalNoOfRecords"];
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(Template.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemplateSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalNoOfRecords"] = this.totalNoOfRecords;
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITemplateSearchResult {
    totalNoOfRecords?: number;
    records?: Template[] | undefined;
}

export class TemplateSearchResultApiResponse implements ITemplateSearchResultApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateSearchResult;
    hasError?: boolean;

    constructor(data?: ITemplateSearchResultApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? TemplateSearchResult.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TemplateSearchResultApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateSearchResultApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITemplateSearchResultApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateSearchResult;
    hasError?: boolean;
}

export class TemplateStages implements ITemplateStages {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    templateId?: number | undefined;
    stageLevel?: number;
    roleId?: number;
    actionId?: number;
    nextStageID?: number | undefined;
    approverId?: number | undefined;
    processId?: number;
    status?: number | undefined;
    auditroleid?: number;
    assessmentId?: number | undefined;

    constructor(data?: ITemplateStages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.templateId = _data["templateId"];
            this.stageLevel = _data["stageLevel"];
            this.roleId = _data["roleId"];
            this.actionId = _data["actionId"];
            this.nextStageID = _data["nextStageID"];
            this.approverId = _data["approverId"];
            this.processId = _data["processId"];
            this.status = _data["status"];
            this.auditroleid = _data["auditroleid"];
            this.assessmentId = _data["assessmentId"];
        }
    }

    static fromJS(data: any): TemplateStages {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateStages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["templateId"] = this.templateId;
        data["stageLevel"] = this.stageLevel;
        data["roleId"] = this.roleId;
        data["actionId"] = this.actionId;
        data["nextStageID"] = this.nextStageID;
        data["approverId"] = this.approverId;
        data["processId"] = this.processId;
        data["status"] = this.status;
        data["auditroleid"] = this.auditroleid;
        data["assessmentId"] = this.assessmentId;
        return data;
    }
}

export interface ITemplateStages {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    templateId?: number | undefined;
    stageLevel?: number;
    roleId?: number;
    actionId?: number;
    nextStageID?: number | undefined;
    approverId?: number | undefined;
    processId?: number;
    status?: number | undefined;
    auditroleid?: number;
    assessmentId?: number | undefined;
}

export class TemplateStagesDto implements ITemplateStagesDto {
    id?: number | undefined;
    processName?: string | undefined;
    templateId?: number;
    templateName?: string | undefined;
    approverId?: number | undefined;
    roleId?: number | undefined;
    actionId?: number | undefined;
    stageLevel?: number;
    complianceId?: number;
    complianceName?: string | undefined;
    processId?: number | undefined;
    templateStageId?: number | undefined;
    status?: number | undefined;
    responseJson?: { [key: string]: any; } | undefined;
    auditroleid?: number;
    auditingProcess?: number;
    auditId?: number;
    auditName?: string | undefined;
    periodId?: number;
    querystatus?: number | undefined;
    assessmentGroupId?: number | undefined;
    assessmentGroupName?: string | undefined;
    endDate?: string | undefined;
    issueStatus?: string | undefined;
    metricGroupId?: number;

    constructor(data?: ITemplateStagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processName = _data["processName"];
            this.templateId = _data["templateId"];
            this.templateName = _data["templateName"];
            this.approverId = _data["approverId"];
            this.roleId = _data["roleId"];
            this.actionId = _data["actionId"];
            this.stageLevel = _data["stageLevel"];
            this.complianceId = _data["complianceId"];
            this.complianceName = _data["complianceName"];
            this.processId = _data["processId"];
            this.templateStageId = _data["templateStageId"];
            this.status = _data["status"];
            if (_data["responseJson"]) {
                this.responseJson = {} as any;
                for (let key in _data["responseJson"]) {
                    if (_data["responseJson"].hasOwnProperty(key))
                        (<any>this.responseJson)![key] = _data["responseJson"][key];
                }
            }
            this.auditroleid = _data["auditroleid"];
            this.auditingProcess = _data["auditingProcess"];
            this.auditId = _data["auditId"];
            this.auditName = _data["auditName"];
            this.periodId = _data["periodId"];
            this.querystatus = _data["querystatus"];
            this.assessmentGroupId = _data["assessmentGroupId"];
            this.assessmentGroupName = _data["assessmentGroupName"];
            this.endDate = _data["endDate"];
            this.issueStatus = _data["issueStatus"];
            this.metricGroupId = _data["metricGroupId"];
        }
    }

    static fromJS(data: any): TemplateStagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateStagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processName"] = this.processName;
        data["templateId"] = this.templateId;
        data["templateName"] = this.templateName;
        data["approverId"] = this.approverId;
        data["roleId"] = this.roleId;
        data["actionId"] = this.actionId;
        data["stageLevel"] = this.stageLevel;
        data["complianceId"] = this.complianceId;
        data["complianceName"] = this.complianceName;
        data["processId"] = this.processId;
        data["templateStageId"] = this.templateStageId;
        data["status"] = this.status;
        if (this.responseJson) {
            data["responseJson"] = {};
            for (let key in this.responseJson) {
                if (this.responseJson.hasOwnProperty(key))
                    (<any>data["responseJson"])[key] = (<any>this.responseJson)[key];
            }
        }
        data["auditroleid"] = this.auditroleid;
        data["auditingProcess"] = this.auditingProcess;
        data["auditId"] = this.auditId;
        data["auditName"] = this.auditName;
        data["periodId"] = this.periodId;
        data["querystatus"] = this.querystatus;
        data["assessmentGroupId"] = this.assessmentGroupId;
        data["assessmentGroupName"] = this.assessmentGroupName;
        data["endDate"] = this.endDate;
        data["issueStatus"] = this.issueStatus;
        data["metricGroupId"] = this.metricGroupId;
        return data;
    }
}

export interface ITemplateStagesDto {
    id?: number | undefined;
    processName?: string | undefined;
    templateId?: number;
    templateName?: string | undefined;
    approverId?: number | undefined;
    roleId?: number | undefined;
    actionId?: number | undefined;
    stageLevel?: number;
    complianceId?: number;
    complianceName?: string | undefined;
    processId?: number | undefined;
    templateStageId?: number | undefined;
    status?: number | undefined;
    responseJson?: { [key: string]: any; } | undefined;
    auditroleid?: number;
    auditingProcess?: number;
    auditId?: number;
    auditName?: string | undefined;
    periodId?: number;
    querystatus?: number | undefined;
    assessmentGroupId?: number | undefined;
    assessmentGroupName?: string | undefined;
    endDate?: string | undefined;
    issueStatus?: string | undefined;
    metricGroupId?: number;
}

export class TemplateStagesDtoListApiResponse implements ITemplateStagesDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateStagesDto[] | undefined;
    hasError?: boolean;

    constructor(data?: ITemplateStagesDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TemplateStagesDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TemplateStagesDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateStagesDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITemplateStagesDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateStagesDto[] | undefined;
    hasError?: boolean;
}

export class TemplateStagesListApiResponse implements ITemplateStagesListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateStages[] | undefined;
    hasError?: boolean;

    constructor(data?: ITemplateStagesListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TemplateStages.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TemplateStagesListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateStagesListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITemplateStagesListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateStages[] | undefined;
    hasError?: boolean;
}

export class TemplateStatus implements ITemplateStatus {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: ITemplateStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): TemplateStatus {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ITemplateStatus {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class TemplateStatusIEnumerableApiResponse implements ITemplateStatusIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateStatus[] | undefined;
    hasError?: boolean;

    constructor(data?: ITemplateStatusIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TemplateStatus.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TemplateStatusIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateStatusIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITemplateStatusIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplateStatus[] | undefined;
    hasError?: boolean;
}

export class TemplayteMetricGroupDto implements ITemplayteMetricGroupDto {
    templateId?: number;
    metricGroupId?: number;
    metricGroupName?: string | undefined;

    constructor(data?: ITemplayteMetricGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            this.metricGroupId = _data["metricGroupId"];
            this.metricGroupName = _data["metricGroupName"];
        }
    }

    static fromJS(data: any): TemplayteMetricGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplayteMetricGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        data["metricGroupId"] = this.metricGroupId;
        data["metricGroupName"] = this.metricGroupName;
        return data;
    }
}

export interface ITemplayteMetricGroupDto {
    templateId?: number;
    metricGroupId?: number;
    metricGroupName?: string | undefined;
}

export class TemplayteMetricGroupDtoListApiResponse implements ITemplayteMetricGroupDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplayteMetricGroupDto[] | undefined;
    hasError?: boolean;

    constructor(data?: ITemplayteMetricGroupDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TemplayteMetricGroupDto.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TemplayteMetricGroupDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplayteMetricGroupDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITemplayteMetricGroupDtoListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TemplayteMetricGroupDto[] | undefined;
    hasError?: boolean;
}

export class TimeDimension implements ITimeDimension {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: ITimeDimension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): TimeDimension {
        data = typeof data === 'object' ? data : {};
        let result = new TimeDimension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface ITimeDimension {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class TimeDimensionIEnumerableApiResponse implements ITimeDimensionIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TimeDimension[] | undefined;
    hasError?: boolean;

    constructor(data?: ITimeDimensionIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TimeDimension.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TimeDimensionIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TimeDimensionIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITimeDimensionIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: TimeDimension[] | undefined;
    hasError?: boolean;
}

export class Type implements IType {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IType {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class TypeIEnumerableApiResponse implements ITypeIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Type[] | undefined;
    hasError?: boolean;

    constructor(data?: ITypeIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Type.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): TypeIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TypeIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface ITypeIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Type[] | undefined;
    hasError?: boolean;
}

export class UidSearchModel implements IUidSearchModel {
    fromDate?: string | undefined;
    toDate?: string | undefined;
    departmentId?: string | undefined;

    constructor(data?: IUidSearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): UidSearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new UidSearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        data["departmentId"] = this.departmentId;
        return data;
    }
}

export interface IUidSearchModel {
    fromDate?: string | undefined;
    toDate?: string | undefined;
    departmentId?: string | undefined;
}

export class Uom implements IUom {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IUom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Uom {
        data = typeof data === 'object' ? data : {};
        let result = new Uom();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IUom {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class UomIEnumerableApiResponse implements IUomIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Uom[] | undefined;
    hasError?: boolean;

    constructor(data?: IUomIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Uom.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): UomIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UomIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IUomIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: Uom[] | undefined;
    hasError?: boolean;
}

export class UploadedFile implements IUploadedFile {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    blobUrl?: string | undefined;
    uploadedFileStatusId?: number | undefined;
    templateId?: number | undefined;
    goalSettingId?: number | undefined;
    metricStandardId?: number | undefined;
    assessmentId?: number | undefined;
    auditId?: number | undefined;
    templateStageId?: number | undefined;
    metricId?: number | undefined;

    constructor(data?: IUploadedFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.name = _data["name"];
            this.blobUrl = _data["blobUrl"];
            this.uploadedFileStatusId = _data["uploadedFileStatusId"];
            this.templateId = _data["templateId"];
            this.goalSettingId = _data["goalSettingId"];
            this.metricStandardId = _data["metricStandardId"];
            this.assessmentId = _data["assessmentId"];
            this.auditId = _data["auditId"];
            this.templateStageId = _data["templateStageId"];
            this.metricId = _data["metricId"];
        }
    }

    static fromJS(data: any): UploadedFile {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["blobUrl"] = this.blobUrl;
        data["uploadedFileStatusId"] = this.uploadedFileStatusId;
        data["templateId"] = this.templateId;
        data["goalSettingId"] = this.goalSettingId;
        data["metricStandardId"] = this.metricStandardId;
        data["assessmentId"] = this.assessmentId;
        data["auditId"] = this.auditId;
        data["templateStageId"] = this.templateStageId;
        data["metricId"] = this.metricId;
        return data;
    }
}

export interface IUploadedFile {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    name?: string | undefined;
    blobUrl?: string | undefined;
    uploadedFileStatusId?: number | undefined;
    templateId?: number | undefined;
    goalSettingId?: number | undefined;
    metricStandardId?: number | undefined;
    assessmentId?: number | undefined;
    auditId?: number | undefined;
    templateStageId?: number | undefined;
    metricId?: number | undefined;
}

export class UploadedFileData implements IUploadedFileData {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    uploadedFileId?: number;
    columnData?: string | undefined;
    status?: string | undefined;
    appuserid?: number | undefined;
    isForm?: boolean | undefined;
    rejectedComments?: string | undefined;
    assessmentId?: number | undefined;
    auditId?: number | undefined;
    templateStageId?: number | undefined;

    constructor(data?: IUploadedFileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.uploadedFileId = _data["uploadedFileId"];
            this.columnData = _data["columnData"];
            this.status = _data["status"];
            this.appuserid = _data["appuserid"];
            this.isForm = _data["isForm"];
            this.rejectedComments = _data["rejectedComments"];
            this.assessmentId = _data["assessmentId"];
            this.auditId = _data["auditId"];
            this.templateStageId = _data["templateStageId"];
        }
    }

    static fromJS(data: any): UploadedFileData {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFileData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["uploadedFileId"] = this.uploadedFileId;
        data["columnData"] = this.columnData;
        data["status"] = this.status;
        data["appuserid"] = this.appuserid;
        data["isForm"] = this.isForm;
        data["rejectedComments"] = this.rejectedComments;
        data["assessmentId"] = this.assessmentId;
        data["auditId"] = this.auditId;
        data["templateStageId"] = this.templateStageId;
        return data;
    }
}

export interface IUploadedFileData {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    uploadedFileId?: number;
    columnData?: string | undefined;
    status?: string | undefined;
    appuserid?: number | undefined;
    isForm?: boolean | undefined;
    rejectedComments?: string | undefined;
    assessmentId?: number | undefined;
    auditId?: number | undefined;
    templateStageId?: number | undefined;
}

export class UploadedFileDataDto implements IUploadedFileDataDto {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    uploadedFileId?: number;
    columnData?: { [key: string]: any; } | undefined;
    status?: string | undefined;
    appuserid?: number | undefined;
    isForm?: boolean | undefined;
    rejectedComments?: string | undefined;
    assessmentId?: number | undefined;
    auditId?: number | undefined;
    templateStageId?: number | undefined;

    constructor(data?: IUploadedFileDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.uploadedFileId = _data["uploadedFileId"];
            if (_data["columnData"]) {
                this.columnData = {} as any;
                for (let key in _data["columnData"]) {
                    if (_data["columnData"].hasOwnProperty(key))
                        (<any>this.columnData)![key] = _data["columnData"][key];
                }
            }
            this.status = _data["status"];
            this.appuserid = _data["appuserid"];
            this.isForm = _data["isForm"];
            this.rejectedComments = _data["rejectedComments"];
            this.assessmentId = _data["assessmentId"];
            this.auditId = _data["auditId"];
            this.templateStageId = _data["templateStageId"];
        }
    }

    static fromJS(data: any): UploadedFileDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFileDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["uploadedFileId"] = this.uploadedFileId;
        if (this.columnData) {
            data["columnData"] = {};
            for (let key in this.columnData) {
                if (this.columnData.hasOwnProperty(key))
                    (<any>data["columnData"])[key] = (<any>this.columnData)[key];
            }
        }
        data["status"] = this.status;
        data["appuserid"] = this.appuserid;
        data["isForm"] = this.isForm;
        data["rejectedComments"] = this.rejectedComments;
        data["assessmentId"] = this.assessmentId;
        data["auditId"] = this.auditId;
        data["templateStageId"] = this.templateStageId;
        return data;
    }
}

export interface IUploadedFileDataDto {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    uploadedFileId?: number;
    columnData?: { [key: string]: any; } | undefined;
    status?: string | undefined;
    appuserid?: number | undefined;
    isForm?: boolean | undefined;
    rejectedComments?: string | undefined;
    assessmentId?: number | undefined;
    auditId?: number | undefined;
    templateStageId?: number | undefined;
}

export class UploadedFileDataDtoApiResponse implements IUploadedFileDataDtoApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UploadedFileDataDto;
    hasError?: boolean;

    constructor(data?: IUploadedFileDataDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? UploadedFileDataDto.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): UploadedFileDataDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFileDataDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IUploadedFileDataDtoApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UploadedFileDataDto;
    hasError?: boolean;
}

export class UploadedFileDataListApiResponse implements IUploadedFileDataListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UploadedFileData[] | undefined;
    hasError?: boolean;

    constructor(data?: IUploadedFileDataListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(UploadedFileData.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): UploadedFileDataListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFileDataListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IUploadedFileDataListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UploadedFileData[] | undefined;
    hasError?: boolean;
}

export class UploadedFileListApiResponse implements IUploadedFileListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UploadedFile[] | undefined;
    hasError?: boolean;

    constructor(data?: IUploadedFileListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(UploadedFile.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): UploadedFileListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFileListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IUploadedFileListApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UploadedFile[] | undefined;
    hasError?: boolean;
}

export class UploadedFileStatus implements IUploadedFileStatus {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IUploadedFileStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): UploadedFileStatus {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFileStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IUploadedFileStatus {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export class UploadedFileStatusIEnumerableApiResponse implements IUploadedFileStatusIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UploadedFileStatus[] | undefined;
    hasError?: boolean;

    constructor(data?: IUploadedFileStatusIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(UploadedFileStatus.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): UploadedFileStatusIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFileStatusIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IUploadedFileStatusIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UploadedFileStatus[] | undefined;
    hasError?: boolean;
}

export class UserListItemModel implements IUserListItemModel {
    id?: number;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    isActive?: boolean;
    ismailverified?: boolean;
    role?: string | undefined;
    roleId?: number | undefined;
    tenantId?: number | undefined;
    genderId?: number | undefined;
    rolelevel?: string | undefined;
    age?: number | undefined;

    constructor(data?: IUserListItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.isActive = _data["isActive"];
            this.ismailverified = _data["ismailverified"];
            this.role = _data["role"];
            this.roleId = _data["roleId"];
            this.tenantId = _data["tenantId"];
            this.genderId = _data["genderId"];
            this.rolelevel = _data["rolelevel"];
            this.age = _data["age"];
        }
    }

    static fromJS(data: any): UserListItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["isActive"] = this.isActive;
        data["ismailverified"] = this.ismailverified;
        data["role"] = this.role;
        data["roleId"] = this.roleId;
        data["tenantId"] = this.tenantId;
        data["genderId"] = this.genderId;
        data["rolelevel"] = this.rolelevel;
        data["age"] = this.age;
        return data;
    }
}

export interface IUserListItemModel {
    id?: number;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    isActive?: boolean;
    ismailverified?: boolean;
    role?: string | undefined;
    roleId?: number | undefined;
    tenantId?: number | undefined;
    genderId?: number | undefined;
    rolelevel?: string | undefined;
    age?: number | undefined;
}

export class UserListItemModelSearchResult implements IUserListItemModelSearchResult {
    totalNoOfRecords?: number;
    records?: UserListItemModel[] | undefined;

    constructor(data?: IUserListItemModelSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalNoOfRecords = _data["totalNoOfRecords"];
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(UserListItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserListItemModelSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemModelSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalNoOfRecords"] = this.totalNoOfRecords;
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserListItemModelSearchResult {
    totalNoOfRecords?: number;
    records?: UserListItemModel[] | undefined;
}

export class UserListItemModelSearchResultApiResponse implements IUserListItemModelSearchResultApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UserListItemModelSearchResult;
    hasError?: boolean;

    constructor(data?: IUserListItemModelSearchResultApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? UserListItemModelSearchResult.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): UserListItemModelSearchResultApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemModelSearchResultApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IUserListItemModelSearchResultApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: UserListItemModelSearchResult;
    hasError?: boolean;
}

export class ValidationDomainModel implements IValidationDomainModel {
    type?: ValidationListEnum;
    input?: any | undefined;

    constructor(data?: IValidationDomainModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.input = _data["input"];
        }
    }

    static fromJS(data: any): ValidationDomainModel {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationDomainModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["input"] = this.input;
        return data;
    }
}

export interface IValidationDomainModel {
    type?: ValidationListEnum;
    input?: any | undefined;
}

export class ValidationList implements IValidationList {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;

    constructor(data?: IValidationList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ValidationList {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }
}

export interface IValidationList {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    description?: string | undefined;
    name?: string | undefined;
    code?: number;
}

export enum ValidationListEnum {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
}

export class ValidationListIEnumerableApiResponse implements IValidationListIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ValidationList[] | undefined;
    hasError?: boolean;

    constructor(data?: IValidationListIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ValidationList.fromJS(item));
            }
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): ValidationListIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationListIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IValidationListIEnumerableApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: ValidationList[] | undefined;
    hasError?: boolean;
}

export class WorkflowRun implements IWorkflowRun {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    recordId?: number;
    process?: string | undefined;
    description?: string | undefined;
    tableMetadataId?: number;
    trigger?: string | undefined;
    configJson?: string | undefined;

    constructor(data?: IWorkflowRun) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.dateCreated = _data["dateCreated"];
            this.dateModified = _data["dateModified"];
            this.id = _data["id"];
            this.updatedBy = _data["updatedBy"];
            this.isActive = _data["isActive"];
            this.recordId = _data["recordId"];
            this.process = _data["process"];
            this.description = _data["description"];
            this.tableMetadataId = _data["tableMetadataId"];
            this.trigger = _data["trigger"];
            this.configJson = _data["configJson"];
        }
    }

    static fromJS(data: any): WorkflowRun {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRun();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["dateCreated"] = this.dateCreated;
        data["dateModified"] = this.dateModified;
        data["id"] = this.id;
        data["updatedBy"] = this.updatedBy;
        data["isActive"] = this.isActive;
        data["recordId"] = this.recordId;
        data["process"] = this.process;
        data["description"] = this.description;
        data["tableMetadataId"] = this.tableMetadataId;
        data["trigger"] = this.trigger;
        data["configJson"] = this.configJson;
        return data;
    }
}

export interface IWorkflowRun {
    createdBy?: number;
    dateCreated?: string;
    dateModified?: string;
    id?: number;
    updatedBy?: number;
    isActive?: boolean;
    recordId?: number;
    process?: string | undefined;
    description?: string | undefined;
    tableMetadataId?: number;
    trigger?: string | undefined;
    configJson?: string | undefined;
}

export class WorkflowRunApiResponse implements IWorkflowRunApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: WorkflowRun;
    hasError?: boolean;

    constructor(data?: IWorkflowRunApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.requestKey = _data["requestKey"];
            this.message = _data["message"];
            this.detail = _data["detail"];
            this.result = _data["result"] ? WorkflowRun.fromJS(_data["result"]) : <any>undefined;
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): WorkflowRunApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRunApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["requestKey"] = this.requestKey;
        data["message"] = this.message;
        data["detail"] = this.detail;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        return data;
    }
}

export interface IWorkflowRunApiResponse {
    code?: number | undefined;
    requestKey?: string | undefined;
    message?: string | undefined;
    detail?: string | undefined;
    result?: WorkflowRun;
    hasError?: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}